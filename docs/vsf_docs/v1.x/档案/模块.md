# 模块

提醒

这份文件是*存档*和*不*具有这是最新版本的有关`1.11`在写作的时间。请记住，本文档旨在帮助您维护旧产品，而不是全新安装。

## [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#introduction)介绍

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#table-of-contents)目录

**介绍和动机**

- [什么是 VS 模块](https://docs.vuestorefront.io/v1/guide/archives/modules.html#what-are-vs-modules)
- [动机](https://docs.vuestorefront.io/v1/guide/archives/modules.html#motivation)
- [VS 模块的目的是什么？](https://docs.vuestorefront.io/v1/guide/archives/modules.html#what-is-the-purpose-of-vs-modules)

**技术部分**

- [模块配置及其功能](https://docs.vuestorefront.io/v1/guide/archives/modules.html#module-config-and-capabilities)
- [模块文件结构](https://docs.vuestorefront.io/v1/guide/archives/modules.html#module-file-structure)
- [模块注册](https://docs.vuestorefront.io/v1/guide/archives/modules.html#module-registration)

**常见用例的模式和良好实践**

- [一般规则和良好做法](https://docs.vuestorefront.io/v1/guide/archives/modules.html#general-rules-and-good-practices)
- [添加新功能作为 VS 模块](https://docs.vuestorefront.io/v1/guide/archives/modules.html#adding-new-features-as-vs-modules)
- [扩展和覆盖 Vue Storefront 模块](https://docs.vuestorefront.io/v1/guide/archives/modules.html#extending-and-overriding-vue-storefront-modules)
- [创建第三方模块](https://docs.vuestorefront.io/v1/guide/archives/modules.html#Creating-3rd-party-modules)

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#what-are-vs-modules)什么是 VS 模块？

您可以将每个模块视为 Vue Storefront 中可用的一个独立功能，其中包含其所有逻辑和依赖项。然而，这一*特征*是一个共同点，它将内部的所有特征联系起来。例如，将产品添加到购物车、接收购物车中的商品列表或应用购物车优惠券的公分母显然是 a`cart`并且`cart`不是任何大于其自身的特征（其公分母是商店）所以它应该是一个模块。Wishlist、Reviews 或 Newsletter 也是该模块的好例子，因为我们直观地将它们视为独立的功能。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#motivation)动机

我相信一个明显的比喻可以清楚地描述问题，同时，解决方案。

为了更好地说明整个概念，我将尝试用乐高积木来解释它。

假设我们有一个装有 90 块乐高积木的盒子，我们可以用它来建造一些奇特的东西，例如塔、城堡或直升机。不幸的是，由于一些愚蠢的欧盟规定，我们的盒子里只能有 3 种不同颜色的积木。众所周知，对于可以建造的每个结构，并非每种颜色都是准确的，因此我们需要不时地在商店中将一种颜色与另一种颜色交换，以便获得最适合我们下一个乐高项目的颜色的积木.

很酷，但有一个问题——因为我们把所有的积木都放在一个盒子里，它们看起来或多或少如下：

![乐高](https://docs.vuestorefront.io/v1/assets/img/pile_of_legos.8c6300ed.png)

当我们想用黑色的砖块替换绿砖时，我们需要在所有其他砖块中分别寻找每块绿砖，这会花费很多时间......而且我们仍然有可能会错过一些其中！更不用说找到我们正在建造的棕榈树所需的特定绿色砖块 ( ![这个！](data:image/jpeg;base64,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)) 将需要在所有其他砖块中寻找它，这会使这项任务变得极其困难和耗时。

这显然不是我们希望以我们的小乐高帝国结束的情况。我们也不希望它与 Vue Storefront 一起使用，因为它意味着易于扩展，因此您可以将绿色砖块（或当前用户购物车功能/cms 提供商/cms 内容提供商）替换为黑色砖块（具有多个购物车的不同购物车功能，WordPress 代替） Prismic 的内容等），而无需在所有积木中寻找每一个积木，也不必担心您会错过其中的一些，否则欧盟将没收您拥有的所有积木！我们还希望更容易找到我们现在想要完成这棵该死的棕榈树的正确砖块！

那么我们如何让这种可怕的情况变得更好呢？

介绍......（鼓声在背景中堆积）***按颜色分组的砖块\***！（在后台哇）

![乐高2](https://docs.vuestorefront.io/v1/assets/img/organized_lego_bricks.3b6473e7.jpeg)

当我们将积木按颜色分组（并在单独的框 - 模块中）时，更容易找到棕榈树所需的绿色积木，因为我们只需要搜索所有积木的一小部分。此外，当我们想用黑色砖块替换绿色砖块时，不是一一寻找所有绿色代表，而是将它们的盒子替换为装有黑色砖块的盒子。我们也不必担心是否有遗漏，因为我们知道所有的绿砖都在盒子里。

这就是我们在 Vue Storefront 中寻找的模块化和可扩展性以及我们目前正在将其重写的架构。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#what-is-the-purpose-of-vs-modules)VS 模块的目的是什么？

在[这个讨论中](https://github.com/vuestorefront/vue-storefront/issues/1213)很好地描述了目的[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/issues/1213). 可以概括为：

- **更好的可扩展性**：我们可以扩展每个模块或用新的模块完全替换它。例如，我们可能希望将 Cart 模块替换为允许拥有多个购物车的模块。使用模块方法，我们可以分离当前的 Cart 模块并将其替换为新的模块。另一个例子可以是为不同的内容 CMSes 集成等使用不同的模块。
- **更好的开发人员体验**：除了模块，我们还引入了许多功能，专注于为开发人员提供更好、更轻松的体验，让他们以更可预测的方式继续前进。我们改变了您使用功能、添加单元测试、TypeScript 接口等组合组件的方式。
- **更好的可升级性**：每个模块都是一个单独的 NPM 包，因此可以独立升级，并且由于它封装了所有逻辑，因此在分离、修改或替换时不应该破坏应用程序的任何其他部分。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#module-config-and-capabilities)模块配置和功能

Module config 是实例化 VS 模块所需的对象。您提供的配置对象稍后用于扩展和挂钩到应用程序的不同部分（例如路由器、Vuex 等）。请将此对象用作负责扩展 Vue Storefront 的唯一部分。否则它可能会在一些破坏性的核心更新后停止工作。

应将具有提供的配置的 Vue Storefront 模块对象导出到`index.ts`入口点。理想情况下，它应该是一个与模块键名称相同的*导出*。

Vue Storefront Module 的签名如下所示：

```js
interface VueStorefrontModuleConfig {
  key: string;
  store?: {
    modules?: { key: string, module: Module<any, any> }[],
    plugin?: Function,
  };
  router?: {
    routes?: RouteConfig[],
    beforeEach?: NavigationGuard,
    afterEach?: NavigationGuard,
  };
  beforeRegistration?: (VSF) => void;
  afterRegistration?: (VSF) => void;
}
```

[在这里](https://github.com/vuestorefront/vue-storefront/blob/develop/core/modules/index.ts)查看代码[（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/core/modules/index.ts)

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#key-required)`key` （必需的）

键是模块的 ID。它用于标识您的模块并在该模块关联的所有基于密钥的扩展中设置密钥（例如，创建命名空间存储）。这个键应该是唯一的。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#store)`store`

Vuex 的入口点。

- `modules` - 在给定键下注册的 Vuex 模块数组
- `plugin` - 你可以在这里提供你自己的 Vuex 插件

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#router)`router`

vue-router 的入口点。您可以提供额外的路线和[导航守卫 （打开新窗口）](https://router.vuejs.org/guide/advanced/navigation-guards.html)这里。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#beforeregistration)`beforeRegistration`

在服务器端和客户端注册模块之前将调用的函数。您可以在此处访问 VSF 对象。

该`VSF`对象是您的 Vue Storefront 商店的一个实例。它包含以下属性

```js
    Vue?: VueConstructor,
    config?: Object,
    store?: Store<RootState>,
    isServer?: boolean
```

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#afterregistration)`afterRegistration`

在服务器端和客户端注册模块后将调用的函数。您可以在此处访问 VSF 对象。

该`VSF`对象是您的 Vue Storefront 商店的一个实例。它包含以下属性

```js
    Vue?: VueConstructor,
    config?: Object,
    store?: Store<RootState>,
    isServer?: boolean
```

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#module-file-structure)模块文件结构

您可以在下面看到 VS 模块的推荐文件结构。所有的核心都是以这种方式组织的。尝试在您创建的文件中使用类似的文件结构。如果所有模块都使用类似的架构来实现，那么维护和理解它们会容易得多。请避免对设计进行不必要的更改，除非另有要求。

并非所有这些文件夹和文件都应该存在于每个模块中。唯一的强制性文件是`index.ts`哪个是入口点。其余的取决于您的需求和模块功能。

你可以看看[模块模板 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/tree/master/core/modules/module-template)带有配置中列出的所有功能的示例实现。

- `components`- 与此模块相关的组件逻辑（例如 Cart 模块的 Microcart）。通常它包含`.ts`文件，但`.vue`如果组件需要开箱即用，您也可以创建文件并提供一些基线标记。

- `pages`- 如果您想提供模块的完整页面，请将它们放在这里。为这些页面扩展路由器配置也是一个好习惯

- ```
  store
  ```

  \- 与此模块关联的 Vuex 模块。你也可以在这里放置 Vuex 模块扩展

  - `index.ts`- Vuex 模块的入口点和主要出口。如果逻辑太复杂而无法将其保存在一个文件中，则可以将操作/getter/mutations 拆分为不同的文件。应该在`store`配置属性中使用。
  - `mutation-types.ts` - 由变量表示的变异字符串代替普通字符串使用
  - `plugins.ts`- 放置 vuex 插件的好地方。应该在`store.plugins`配置对象中使用

- `types` - 与模块关联的 TypeScript 类型

- `test`- 包含每个新模块或重写模块*所需的*单元测试的文件夹。

- ```
  hooks
  ```

   \- 在模块注册之前和之后调用的之前/之后的钩子。

  - `beforeRegistration.ts`- 应该在`beforeRegistration`配置属性中使用。
  - `afterRegistration.ts`- 应该在`afterRegistration`配置属性中使用。

- ```
  router
  ```

   \- 与此模块相关的路线和导航守卫

  - `routes.ts`- 将添加到当前路由器配置的路由对象数组。应该在`router.routes`配置属性中使用。
  - `beforeEach.ts`- beforeEach 导航守卫。应该在`router.beforeEach`配置属性中使用。
  - `afterEach.ts`- afterEach 导航守卫。应该在`router.afterEach`配置属性中使用。

- `queries` - GraphQL 查询

- `helpers` - 旨在支持模块行为的所有其他内容

- `index.js`- 模块的入口点。应该导出 VueStorefrontModule。它也是实例化缓存存储的好地方。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#module-registration)模块注册

包括核心模块在内的所有模块都在`src/modules/index.ts`文件中注册。由于这种方法，您可以在注册之前轻松修改任何核心模块对象（[在此处](https://docs.vuestorefront.io/v1/guide/archives/modules.html#extending-and-overriding-vue-storefront-modules)阅读更多内容）。

所有 VS 模块`registerModules`都将在商店初始化期间注册。

------

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#general-rules-and-good-practices)一般规则和良好做法

首先，看看模块模板。它包含很好的例子、良好的实践和对可以放在模块中的所有内容的解释。

1. **最重要的规则**尝试隔离模块正常工作所需的所有逻辑，并将它们放入模块中。您可以从应用程序的其他部分导入它，但逻辑本身应该存在于模块中
2. **尽量不要依赖任何其他模块。将所有内容封装起来，只依赖核心助手和库**。仅当这是实现功能和`rootStore`为此目的导入的唯一方法时才使用其他商店。模块应该独立工作并且只依赖于它们自己。尝试将每个模块视为独立的 npm 包。
3. 将所有可重用功能作为 Vuex 操作（例如`addToCart(product)`，`subscribeNewsletter()`等）放置，而不是将它们放置在组件中。尝试使用 getter 来修改或过滤状态中的值。我们正在尝试将大部分逻辑放在 Vuex 商店中，以便更轻松地进行核心更新。这是这种外化的一个很好的例子。

```js
export const Microcart = {
  name: 'Microcart',
  computed: {
    productsInCart(): Product[] {
      return this.$store.state.cart.cartItems;
    },
    appliedCoupon(): AppliedCoupon | false {
      return this.$store.getters['cart/coupon'];
    },
    totals(): CartTotalSegments {
      return this.$store.getters['cart/totals'];
    },
    isMicrocartOpen(): boolean {
      return this.$store.state.ui.microcart;
    },
  },
  methods: {
    applyCoupon(code: String): Promise<boolean> {
      return this.$store.dispatch('cart/applyCoupon', code);
    },
    removeCoupon(): Promise<boolean> {
      return this.$store.dispatch('cart/removeCoupon');
    },
    toggleMicrocart(): void {
      this.$store.dispatch('ui/toggleMicrocart');
    },
  },
};
```

1. 如果您想通知核心组件方法的成功/失败，您可以使用回调或作用域事件。如果您认为可以从模板调用该函数并且您需要解析的值，请省略 Promises。这是您可以在 on`template`或`script`section 中调用的方法的一个很好的示例：

```js
addToCart(product, success, failure) {
  this.$store.dispatch('cart/addToCart').then(res =>
    success(res)
  ).catch(err =>
    failure(err)
  )
}
```

尝试根据用例选择一种方法。[这个 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/core/modules/mailchimp/components/Subscribe.ts#L28)是使用回调的一个很好的例子。

1. 创建可以使用不同参数轻松调用的纯函数。`data`仅在需要时才依赖属性而不是参数（例如，它们在[此处](https://github.com/vuestorefront/vue-storefront/blob/develop/core/modules/mailchimp/components/Subscribe.ts#L28)验证[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/core/modules/mailchimp/components/Subscribe.ts#L28))
2. 建立文件像如下出口组件：[文件（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/core/modules/mailchimp/components/Subscribe.ts)
3. 如果您的模块核心功能是与外部服务的集成，最好将其命名为与此服务相同的名称（例如`mailchimp`）
4. 使用命名导出和类型检查。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#adding-new-features-as-vs-modules)添加新功能作为 VS 模块

- 如果您想创建一个新模块，请复制内容`src/module-template`并使用您需要的部分。
- 如果您正在创建一项新功能，请注意它不仅仅是扩展现有功能。如果您确定要提供的功能是全新的，则应将其作为新的 VS 模块引入。
- 提供应代表功能或第 3 方系统名称的唯一键（如果模块是集成）
- 如果您的模块未声称直接扩展它，请尽量不要依赖来自其他模块的数据和逻辑。这样做，即使在大量 VS 核心更新之后，它也可以保证继续工作并且更容易重用。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#extending-and-overriding-vue-storefront-modules)扩展和覆盖 Vue Storefront 模块

可以扩展，并且通过提供一个修改的任何登记前的Vue店面模块的所有部分`VueStorefrontModuleConfig`的对象**使用相同的密钥**对`extendModule()`的功能。这个配置会和同一个key的模块深度合并，也就是说：

- 所有具有相同键的 Vuex 存储将被合并（冲突的动作/突变将被覆盖，其他的将被添加）
- 如果提供前/后钩子，存储插件或路由器对象属性等叶子将被新的覆盖。

让我们看一个例子，假设我们想`cart`通过覆盖它的`beforeRegistration`钩子和`load`Vuex 动作来扩展模块。

1. 首先，我们需要准备一个`VueStorefrontModuleConfig`我们将用来扩展`cart`模块的。它必须与`key`我们要扩展的模块具有相同的值。
2. 接下来我们需要将此对象传递给`extendModule`函数
3. 就这样！现在，当您注册`cart`模块时，它将使用提供的配置进行扩展。

```js
import { Cart } from '@vue-storefront/core/modules/cart'

// 1. Preparation of new VSMConfig
const extendCartVuex = {
 actions: {
   load () {
     console.info('hey')
   }
 }
}

const extendCartAfterRegistration = function (VSF) {
   console.info('Hello, im extended now!')
 }

const cartExtend = {
 key: 'cart',
 afterRegistration: extendCartAfterRegistration,
 store: { modules: [{ key: 'cart', module: extendCartVuex }] },
}

// 2. After passing the object to extendModule function it will be merged with Cart module during registration
extendModule(cartExtend)

export const registerModules: VueStorefrontModule[] = [Cart]
```

如果您想对自己的特定于应用程序的 VS 模块（不是 npm 包）进行复杂的更改，最好将此模块保留在`src/modules/{module-name}`. 要使用另一个模块扩展模块，只需将其配置传递给`extendModule`函数

```js
import { Cart } from '@vue-storefront/core/modules/cart'
import { ExtendCartModule } from 'extend-cart';


extendModule(ExtendCartModule.config)

export const registerModules: VueStorefrontModule[] = [Cart]
```

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#creating-third-party-modules)创建第三方模块

如果您想创建第三方模块，只需将`src/modules/module-template`原始代码复制到您的仓库即可。不要使用任何转译和构建工具，因为它会阻止适当的树抖动和优化。构建过程由 Vue Storefront 构建工具处理。包名称需要以`vsf-`前缀开头才能包含在 Vue Storefront 构建过程中。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#contributions)贡献

请将每个新功能作为独立的封装模块介绍。我们还需要您的帮助，将 Vue Storefront 重写为模块化方法 -[在这里 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/issues?q=is%3Aissue+is%3Aopen+label%3A"API+Module")您可以[在此处](https://github.com/vuestorefront/vue-storefront/blob/master/doc/api-modules/refactoring-to-modules.md)找到与此架构更改相关的任务[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/doc/api-modules/refactoring-to-modules.md)是关于如何应用这些更改的教程。

## [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#cart-module)购物车模块

该模块包含与购物车操作相关的所有逻辑、组件和商店。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#components)成分

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#addtocart)添加到购物车

此组件代表一个按钮，按下该按钮可将产品添加到购物车。

**道具**

- `product` - 将添加到购物车的产品

**方法**

- `addToCart(product)`- 将传递的产品添加到购物车。默认情况下与`product`prop相关

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#microcart)微型车

带有产品列表和价格摘要的用户购物车。

**计算**

- `productsInCart` - 当前在购物车中的一系列产品
- `appliedCoupon`- 返回已应用的购物车优惠券或`false`如果未应用优惠券
- `totals` - 购物车总数
- `isMicrocartOpen`-`true`如果微型车打开，则返回

**方法**

- `applyCoupon(code)` - 应用购物车优惠券
- `removeCoupon` - 删除当前应用的购物车优惠券
- `toggleMicrocart` - 打开/关闭微型车

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#microcartbutton)小车按钮

负责打开/关闭 Microcart 的组件

**计算**

- `quantity` - 购物车中的产品数量

**方法**

- `toggleMicrocart` - 打开/关闭微型车

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#product)产品

代表微型购物车中的产品的组件。允许修改它的数量或从购物车中删除。

**计算**

- `thumbnail` - 返回产品缩略图的 src

**方法**

- `removeFromCart`-`product`从购物车中删除当前产品（数据属性）
- `updateQuantity`- 更新当前产品的购物车数量（数据属性`product`）

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#store-2)店铺

Cart Store 旨在处理与购物车相关的所有操作。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#state)状态

```js
  state: {
    itemsAfterPlatformTotals: {},
    platformTotals: null,
    platformTotalSegments: null,
    cartIsLoaded: false,
    cartServerToken: '', // server side ID to synchronize with Backend (for example Magento)
    shipping: [],
    payment: [],
    cartItemsHash: '',
    bypassCount: 0,
    cartItems: [] // TODO: check if it's properly namespaced
  },
```

购物车状态`localForage`在页面加载后自动从集合中加载，只要`core/components/blocks/Microcart.vue`包含。购物车状态通过调度`cart/load`操作加载，并[通过购物车状态的任何更改自动存储 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/c43b2966a9ae10661e5a62b10445403ed9789b32/core/store/index.js#L118).

购物车状态数据：

- `itemsAfterPlatformTotals`- 助手集合，字典，其中键是 Magento 购物车项目`item_id`，存储每个项目的总计信息 - 从 Magento 接收；`config.cart.synchronize_totals`启用时会自动填充；
- `platformTotals`- 与上述项目类似，这里我们有来自 Magento 的当前购物车的全部总数。这些集合由[`cart/syncTotals` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/c43b2966a9ae10661e5a62b10445403ed9789b32/core/store/modules/cart/actions.js#L49)和事件处理程序 [`servercart-after-totals`（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/c43b2966a9ae10661e5a62b10445403ed9789b32/core/store/modules/cart/index.js#L30)
- `cartIsLoaded` (bool) - 调度后为真 `cart/load`
- `shipping`- （对象）当前选择的送货方式 - 仅在不使用时`cart.synchronize_totals`（如果是这样，送货和付款数据来自 Magento2），
- `payment`- （对象）当前选择的送货方式 - 仅在不使用时`cart.synchronize_totals`（如果是这样，送货和付款数据来自 Magento2），
- `cartItems`- 收集购物车物品；项目格式与[ElasticSearch 数据格式中](https://github.com/vuestorefront/vue-storefront/blob/master/doc/ElasticSearch data formats.md)描述的相同[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/doc/ElasticSearch data formats.md)-`product`班级；唯一的区别`qty`是添加了 (int)字段

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#events)活动

以下事件是从`cart`商店发布的：

- `EventBus.$emit('cart-after-itemchanged', { item: cartItem })` - 之后执行 [`servercart-after-itemupdated` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/c43b2966a9ae10661e5a62b10445403ed9789b32/core/store/modules/cart/index.js#L108)- 服务器购物车同步后，表示特定购物车项目已更改；`Microcart/Product.vue`组件订阅此事件以刷新购物车 UI
- `EventBus.$emit('cart-before-add', { product: item })` - 在产品添加到购物车后触发，
- `EventBus.$emit('cart-before-save', { items: state.cartItems })` - 在保存产品购物车后触发，
- `EventBus.$emit('cart-before-delete', { items: state.cartItems })` - 在使用当前购物车状态删除购物车项目之前触发的事件（删除项目之前）
- `EventBus.$emit('cart-after-delete', { items: state.cartItems })` - 在使用当前购物车状态删除购物车项目之前触发的事件（删除项目之后）
- `EventBus.$emit('cart-before-itemchanged', { item: record })`- 在要更改特定项目属性之前调用的项目；例如调用时[`servercart-after-itemupdated` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/c43b2966a9ae10661e5a62b10445403ed9789b32/core/store/modules/cart/index.js#L108)将要更改`server_item_id`属性
- `EventBus.$emit('cart-after-itemchanged', { item: record })`- 在更改特定项目属性后调用的项目；例如调用时[`servercart-after-itemupdated` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/c43b2966a9ae10661e5a62b10445403ed9789b32/core/store/modules/cart/index.js#L108)将要更改`server_item_id`属性
- `EventBus.$emit('application-after-loaded')`-`cart/load`在分派动作后调用的事件，以通知购物车可用，
- `EventBus.$emit('cart-after-updatetotals', { platformTotals: totals, platformTotalSegments: platformTotalSegments })`- 在 Magento 的总数与当前状态同步后调用的事件；只有在`cart.synchronize_totals`启用选项时才会发出它。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#actions)行动

购物车商店提供以下公共操作：

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#disconnect-context)`disconnect (context)`

用于清除当前服务器购物车id的Helper方法（用于购物车同步）

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#clear-context)`clear (context)`

在下订单后调用此方法以清空`cartItems`集合并在`cart.synchronize_totals`设置为 true时创建新的服务器购物车

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#save-context)`save (context)`

用于将购物车保存到`localForage`浏览器集合的方法

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#sync-context-forceclientstate-false)`sync (context, { forceClientState = false })`

此方法用于在服务器和当前客户端状态之间来回同步购物车项目的当前状态。当`forceClientState`设置为 false 时，通信是单向的（客户端 -> 服务器）。当`cart.synchronize`设置为 true时，会在任何购物车更改时自动调用此操作。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#synctotals-context-forceclientstate-false)`syncTotals (context, { forceClientState = false })`

每当购物车总数应该与服务器同步时（在 之后`serverPull`），就会调用方法。此方法覆盖本地购物车总计和特定项目值（例如折扣后的价格）。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#connect-context-guestcart-false)`connect (context, { guestCart = false })`

分派操作以创建服务器购物车并存储购物车 ID（用于进一步同步）

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#load-context)`load (context)`

此方法从`localForage`浏览器状态管理加载购物车项目。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#getitem-commit-dispatch-state-sku)`getItem ({ commit, dispatch, state }, sku)`

此操作用于搜索购物车中的特定商品（按 SKU）

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#additem-commit-dispatch-state-producttoadd-forceserversilence-false)`addItem ({ commit, dispatch, state }, { productToAdd, forceServerSilence = false })`

此操作用于添加`productToAdd`到购物车，如果`config.cart.synchronize`设置为 true ，则随后调用的下一个操作将`serverPull`同步购物车。`cart-before-add`每当新产品进入购物车时都会调用该事件。该选项`forceServerSilence`用于绕过服务器同步，例如，在...同步过程中添加项目以避免循环同步周期。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#removeitem-commit-dispatch-product)`removeItem ({ commit, dispatch }, product)`

正如您想象的那样 😃 此操作只是将产品从购物车中移除，并在设置时同步服务器购物车。您必须至少指定`product.sku`.

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#updatequantity-commit-dispatch-product-qty-forceserversilence-false)`updateQuantity ({ commit, dispatch }, { product, qty, forceServerSilence = false })`

每当用户更改购物车中的产品数量（从 调用）时，都会调用此方法`Microcart.vue`。该参数`qty`是产品的新数量，通过使用`forceServerSilence`您可以控制是否正在执行服务器购物车同步。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#updateitem-commit-product)`updateItem ({ commit }, { product })`

更新项目属性。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#syncpaymentmethods-context)`syncPaymentMethods (context)`

从后端获取付款方式列表并将它们保存到`cart.payment`存储状态。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#syncshippingmethods-context-address)`syncShippingMethods (context, address)`

从后端获取运输方式列表并将它们保存到`cart.shipping`存储状态。国家 ID 在强制`address`参数中传递给此方法。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#synctotals-context-methodsdata)`syncTotals (context, methodsData)`

此方法向后端发送请求以收集购物车总数。它根据付款和运输方式信息是否可用来调用不同的后端端点。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#getters)吸气剂

所有状态成员都应该只能由 getter 访问。请查看数据格式的状态参考

- `getCartToken`- 获取当前的购物车令牌，如果为空，则意味着我们需要`cart/connect`在与服务器同步之前调用一个操作，
- `getLastSyncDate` - 这是一个整数，最后一次购物车与服务器同步的时间戳
- `getLastTotalsSyncDate` - 整数，与服务器同步的最后总数的时间戳，
- `getShippingMethod` - 对象，在结帐中获取当前选择的运输方式，
- `getPaymentMethod` - 对象，获取在结帐中选择的当前付款方式，
- `getLastCartHash`- 获取最后保存的购物车项目的哈希/HMAC + 服务器令牌，让您可以跟踪运输车的变化。服务器同步正在保存哈希，
- `getCurrentCartHash`- 获取购物车项目的当前哈希/HMAC + 服务器令牌。将它与`getLastCartHash`值进行比较，让您知道我们是否需要服务器同步，
- `isCartHashChanged`-比较`getLastCartHash`与`getCurrentCartHash`以验证是否需要一台服务器同步与否，
- `isSyncRequired`- 检查是否`isCartHashChanged`为真或这是第一次同步尝试（在 SSR 之后），
- `isTotalsSyncRequired`- 与`isSyncRequired`但总计（不是购物车项目）相同，
- `isCartHashEmtpyOrChanged`- 检查是否为`isCartHashChanged`空，
- `getCartItems` - 购物车中的一系列产品，
- `isTotalsSyncEnabled`- 检查是否`config.cart.synchronize`为真 + 如果我们在线 + 如果这是 CSR 请求，
- `isCartConnected`- 检查是否`getCartToken`不为空 - 这意味着该`cart/connect`操作已被调用，我们可以与服务器同步，
- `isCartSyncEnabled`- 与`isTotalsSyncEnabled`总计（`config.cart.synchronize_totals`标志）相同，
- `getTotals` - 包含总段的数组，
- `getItemsTotalQuantity` - 获取购物车中所有商品的总和，
- `getCoupon` - 获取当前应用的折扣代码，

## [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#user-module)用户模块

该模块包含与用户帐户相关的所有逻辑、组件和存储

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#components-2)成分

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#accountbutton)帐户按钮

处理重定向到用户帐户页面和用户注销的组件。通常用于标题。

**计算**

- `isLoggedIn` - 表示用户是否已登录；
- `user` - 当前用户。

**方法**

- `goToAccount`- 用户是否已登录，将用户重定向到帐户页面。否则显示注册模式
- `logout`- 发出`user-before-logout`事件并将用户重定向到主页

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#login)登录

**方法**

- `close` - 关闭注册模式
- `callLogin`- 启动身份验证过程，使用用户的电子邮件和密码发出`notification-progress-start`，调用`user/login`操作。
- `switchElem`-`setAuthElem`使用`register`参数触发突变
- `callForgotPassword`-`setAuthElem`使用`forgot-pass`参数触发突变

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#register)登记

**方法**

- `switchElem`-`setAuthElem`使用`register`参数触发突变
- `close` - 关闭注册模式
- `callRegister`-使用用户的电子邮件、密码、名字和姓氏开始注册过程，发出`notification-progress-start`、调用`user/register`操作。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#useraccount)用户帐号

**方法**

- `onLoggedIn`- 设置`currentUser`和`userCompany`。此方法在`user-after-loggedin`总线事件上调用
- `edit`- 将`isEdited`标志设置为`true`
- `objectsEqual (a, b, excludedFields = [])` - 检查两个传递的对象是否彼此相等
- `updateProfile`- 使用新数据更新用户配置文件。调用方法`exitSection(null, updatedProfile)`
- `exitSection`-`myAccount-before-updateUser`使用更新的用户配置文件发出总线事件。将组件用户数据重置为默认值。
- `getUserCompany` - 找到用户公司
- `getCountryName` - 查找用户国家名称

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#usershippingdetails)用户发货详情

**方法**

- `onLoggedIn`- 设置`currentUser`和`shippingDetails`。此方法在`user-after-loggedin`总线事件上调用
- `edit`- 将`isEdited`标志设置为`true`
- `updateDetails`- 使用新数据更新运输详细信息。调用方法`updatedShippingDetails`
- `exitSection`- 发出`myAccount-before-updateUser`带有更新运输详细信息的总线事件。将组件用户数据重置为默认值
- `fillCompanyAddress` - 查找运输详细信息
- `getCountryName` - 查找国家名称
- `hasBillingAddres`-`true`如果用户有账单地址则返回

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#store-3)店铺

用户存储旨在处理与用户帐户相关的所有操作。所有与用户相关的数据都存储在原始电子商务 CMS/Magento 中，修改操作直接针对平台 API 执行。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#state-2)状态

```js
  state: {
    token: '',
    current: null
  },
```

用户状态数据：

- `token` - 这是从当前用户获得的令牌 [`user/login` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/fabea12dd6ab4f8824b58812b0cfdabce94cde70/core/store/modules/user/actions.js#L64). 它用于使用当前用户身份授权所有后续调用。如果此令牌不为空，则表示用户已获得授权。
- `current` - 这是从接收到的当前用户对象 [`user/me` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/fabea12dd6ab4f8824b58812b0cfdabce94cde70/core/store/modules/user/actions.js#L105)- 在登录操作后立即调用。

用户数据格式：

```json
{
  "code": 200,
  "result": {
    "id": 58,
    "group_id": 1,
    "default_billing": "62",
    "default_shipping": "48",
    "created_at": "2018-01-23 15:30:00",
    "updated_at": "2018-03-04 06:39:28",
    "created_in": "Default Store View",
    "email": "pkarwatka28@example.pl",
    "firstname": "Piotr",
    "lastname": "Karwatka",
    "store_id": 1,
    "website_id": 1,
    "addresses": [
      {
        "id": 48,
        "customer_id": 58,
        "region": {
          "region_code": null,
          "region": null,
          "region_id": 0
        },
        "region_id": 0,
        "country_id": "PL",
        "street": ["Street", "12"],
        "telephone": "",
        "postcode": "51-169",
        "city": "City",
        "firstname": "Piotr",
        "lastname": "Karwatka",
        "default_shipping": true
      },
      {
        "id": 62,
        "customer_id": 58,
        "region": {
          "region_code": null,
          "region": null,
          "region_id": 0
        },
        "region_id": 0,
        "country_id": "PL",
        "street": ["Street", "12"],
        "company": "example",
        "telephone": "",
        "postcode": "51-169",
        "city": "City",
        "firstname": "Piotr",
        "lastname": "Karwatka",
        "vat_id": "PL8951930748",
        "default_billing": true
      }
    ],
    "disable_auto_group_change": 0
  }
}
```

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#events-2)活动

以下事件是从`user`商店发布的：

- `EventBus.$emit('session-after-started')`-[在应用程序加载后立即](https://github.com/vuestorefront/vue-storefront/blob/fabea12dd6ab4f8824b58812b0cfdabce94cde70/core/store/modules/user/actions.js#L22)执行[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/fabea12dd6ab4f8824b58812b0cfdabce94cde70/core/store/modules/user/actions.js#L22)并且用户界面会话已经开始
- `EventBus.$emit('user-after-loggedin', res)`- 在成功的[动作调用](https://github.com/vuestorefront/vue-storefront/blob/fabea12dd6ab4f8824b58812b0cfdabce94cde70/core/store/modules/user/actions.js#L123)后执行[`user/me` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/fabea12dd6ab4f8824b58812b0cfdabce94cde70/core/store/modules/user/actions.js#L123)- 这样的用户已被授权和配置文件加载

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#actions-2)行动

用户商店提供了以下的公共行为：

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#startsession-context)`startSession (context)`

只是为了标记会话启动和加载从令牌当前用户`localForage`-为进一步使用。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#resetpassword-context-email)`resetPassword (context, { email })`

调用`vue-storefront-api`端点发送密码重置链接到指定`email`地址

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#login-context-username-password)`login (context, { username, password })`

称为登录用户和接收可以用于授权后续API调用的当前令牌。用户成功授权后，`user/me`将调度操作以加载用户配置文件数据。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#register-context-email-firstname-lastname-password)`register (context, { email, firstname, lastname, password })`

在注册的电子商务平台/ Magento的用户帐户。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#me-context-refresh-true-usecache-true)`me (context, { refresh = true, useCache = true })`

加载从电子商务CMS用户配置文件; 当`userCache`设置为true结果将被存储在`localForage`，如果它之前存储-使用从缓存返回`fastest`策略（网络VS高速缓存）。如果`refresh`设置为true -用户数据将会从服务器上拉，尽管缓存副本是可用的。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#update-context-userdata)`update (context, userData)`

这个动作是用来更新各种用户配置文件数据。请检查[用户架构 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/core/store/modules/user/userProfile.schema.json)有关数据格式的详细信息。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#changepassword-context-passworddata)`changePassword (context, passwordData)`

试图更改用户密码`passwordData.newPassword`。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#logout-context)`logout (context)`

这是用来注销用户关闭会话并清除用户令牌。请注意 - 当前的购物车是此调用后关闭。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#getters-2)吸气剂

所有状态成员都应该只能由 getter 访问。请查看数据格式的状态参考

```js
const getters = {
  isLoggedIn(state) {
    return state.current !== null;
  },
};
```

## [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#checkout-module)结账模块

结帐模块旨在处理与结帐操作和 UI 相关的所有逻辑。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#components-3)成分

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#cartsummary)CartSummary

此组件显示购物车汇总信息

**计算**

- `totals` - 映射吸气来显示车汇总

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#orderreview)订单审核

当前的订单摘要

**道具**

- `isActive` - 布尔值，需要的道具

**方法**

- `placeOrder`-如果当前用户具有帐户检查。如果不是，将触发一个`register`方法，否则会发出`checkout-before-placeOrder`总线事件
- `register`- 调度一个`user/register`动作来注册一个新用户

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#payment)支付

一个组件来处理支付业务

**道具**

- `isActive` - 布尔值，需要的道具

**计算**

- `currentUser` - 当前用户从应用状态映射
- `paymentMethods`-可用的付款方式从映射`payment/paymentMethods`的getter

**方法**

- `sendDataToCheckout`-发出`checkout-after-paymentDetails`总线事件，并设置`isFilled`到`true`
- `edit`- 检查`isFilled`，如果是`true`，则发出`checkout-before-edit`总线事件
- `hasBillingData` - 检查当前用户是否存在，如果它有`default_billing_财产
- `initializeBillingAddress`-检查是否当前用户存在，并且如果它具有`default_billing`属性; 如果是这样，填充`payment`用当前用户的地址数据的数据属性
- `useShippingAddress`-填充`payment`数据属性`$store.state.checkout.shippingDetails`
- `useBillingAddress`-填充`payment`数据属性`currentUser.addressess`
- `useGenerateInvoice`-否定的`generateInvoice`价值，如果它变成`false`，将复位`this.payment.company`和`this.payment.taxId`
- `getCountryName` - 通过国家/地区代码获取当前付款的国家/地区名称
- `getPaymentMethod` - 由支付方法的代码获取当前支付的付款方式标题
- `notInMethods` - 检查传递的方法是否存在于 `paymentMethods`
- `changePaymentMethod`-如果存在，并复位额外支付方法组分容器发出`checkout-payment-method-changed`总线事件

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#personal-details)个人资料

用户的个人信息组件

**道具**

- `isActive` - 布尔值，需要的道具
- `focusedField` - 一个字符串显示哪些字段被聚焦

**计算**

- `currentUser` - 当前用户从应用状态映射

**方法**

- `onLoggedIn`-填充`personalDetails`数据作为参数传递
- `sendDataToCheckout`-执行检查是否已经创建了账户并发出`checkout-after-personalDetails`总线事件
- `edit`-发出`checkout-before-edit`总线事件
- `gotoAccount` - 显示了注册模式

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#product-2)产品

表示产品组件

**道具**

- `product` - 当前产品

**计算**

- `thumbnail` - 返回产品图像的缩略图

**方法**

- `onProductChanged`-检查`event.item.sku`，如果它等于`product.sku`，力更新将被触发

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#shipping)船运

组件处理所有的航运逻辑

**道具**

- `isActive` - 布尔值，需要的道具

**计算**

- `currentUser` - 当前用户从应用状态映射
- `shippingMethods`-可用的付款方式从映射`payment/paymentMethods`的getter
- `checkoutShippingDetails` - 映射自 `state.checkout.shippingDetails`
- `paymentMethod` - 映射自 `state.payment.methods`

**方法**

- `onAfterShippingSet`-填充`shipping`与传递的参数数据属性
- `onAfterPersonalDetail`-检查`isFilled`数据属性，如果它的虚假，调度`checkout/updatePropValue`与用户的名字和姓氏
- `sendDataToCheckout`-发射`checkout-after-shippingDetails`总线事件; 套`isFilled`到`true`
- `edit`-是`isFilled`是真实的，发出`checkout-before-edit`总线事件，并设置`isFilled`到`false`
- `hasShippingDetails`-检查，如果`currentUser`存在，并且有一个属性`default_shipping`; 如果是这样，填充`myAddressDetails`数据属性`currentUser.addresses`
- `useMyAddress`-检查`shipToMyAddress`; 如果`true`，填充`shipping`数据属性`myAddressDetails`
- `getShippingMethod`-获取从运输方式`shippingMethods`的数据属性
- `getCountryName` - 使用国家代码获取国家名称
- `changeCountry`-发出`checkout-before-shippingMethods`总线事件
- `getCurrentShippingMethod` - 计算电流的送货方式与航运法码
- `changeShippingMethod`-如果`getCurrentShippingMethod`存在，发出`checkout-after-shippingMethodChanged`总线事件
- `notInMethods` - 检查传递的方法是否存在于 `shippingMethods`

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#how-to-add-a-custom-checkout-step)如何添加自定义结帐步骤

我们现在说明如何添加一个新的台阶，以Vue公司店面的结账页面的例子。

步骤命名`NewStep`，只是在后放置`PersonalDetails`的步骤; 改变步的名称和位置需要稍微修改程序。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#first-create-the-newstep-component)首先，创建NewStep组件

1. **创建NewStep组件**根据您的需要。要迅速行动，使副本`PersonalDetails`组成，命名`NewStep`并进行自定义。
2. **定制sendDataToCheckout方法**的的`NewStep`组分，使得其发射的情况下`checkout-after-newStep`; 例如：

```javascript
    sendDataToCheckout () {
      this.$bus.$emit('checkout-after-newStep', this.newStep, this.$v)
    }
```

1. **调用sendDataToCheckout方法**是单击该按钮下一节时。这可能在这样的模板来实现：

```vue
    <button-full
      @click.native="sendDataToCheckout"
    >
```

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#then-modify-the-checkout-component)然后，修改结帐部件

1. **在结账模板**中的所需位置**插入 NewStep 组件**。例如，你可以把它放在个人资料和运输步骤之间：

```vue
  <personal-details class="line relative" :is-active="activeSection.personalDetails" :focused-field="focusedField"/>
  <new-step class="line relative" :is-active="activeSection.newStep">
  <shipping class="line relative" :is-active="activeSection.shipping" v-if="!isVirtualCart"/>
  <payment class="line relative" :is-active="activeSection.payment"/>
  <order-review class="line relative" :is-active="activeSection.orderReview"/>
```

1. **监听结帐后newStep事件**中加入以下监听器的`beforeMount()`功能：

```javascript
    this.$bus.$on('checkout-after-newStep', this.onAfterNewStep)
```

1. **指定如何从以前的步骤NewStep跳**。修改`onAfterPersonalDetails()`方法以激活`newStep`部分，而不是`shipping`步骤：

```javascript
    onAfterPersonalDetails (receivedData, validationResult) {
      this.personalDetails = receivedData
      this.validationResults.personalDetails = validationResult
      this.activateSection('newStep') // show the new step
      this.savePersonalDetails()
      this.focusedField = null
    }
```

这是假设新的结帐步骤如下个人信息的步骤; 如果不是这样的话，你将需要修改`onAfter`任何步骤先的梅托德`NewStep`。

1. **指定如何从NewStep跳到下一步**创建的方法`onAfterNewStep`; 在这个例子中，下一个步骤是航运形式：

```javascript
    onAfterNewStep (receivedData, validationResult) {
      this.newStep = receivedData
      this.validationResults.newStep = validationResult
      this.activateSection('shipping') // change 'shipping' to whatever you want the next step to be
      this.saveNewStep() // include this line only if newStep has state
    }
```

请注意，调用`activateSection('shipping')`是最终显示的下一个结帐步骤给用户。

1. **如果需要，节省NewStep状态**通过定义一个非空方法`saveNewStep()`; 例如：

```javascript
    saveNewStep () {
      this.$store.dispatch('checkout/saveNewStep', this.newStep)
    },
```

这是只需要你的新步骤都有状态，在这种情况下，你还需要定义`checkout/saveNewStep`在Vuex行动。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#store-4)店铺

Checkout商店是专门用来处理来自用户的购物车，以实际订单的通道; 它定义如保存在结帐时由用户提供的信息，并把该命令的动作。

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#state-3)状态

```js
  state: {
    order: {},
    personalDetails: {
      firstName: '',
      lastName: '',
      emailAddress: '',
      password: '',
      createAccount: false
    },
    shippingDetails: {
      firstName: '',
      lastName: '',
      country: '',
      streetAddress: '',
      apartmentNumber: '',
      city: '',
      state: '',
      region_id: 0,
      zipCode: '',
      phoneNumber: '',
      shippingMethod: ''
    },
    paymentDetails: {
      firstName: '',
      lastName: '',
      company: '',
      country: '',
      streetAddress: '',
      apartmentNumber: '',
      city: '',
      state: '',
      region_id: 0,
      zipCode: '',
      phoneNumber: '',
      taxId: '',
      paymentMethod: '',
      paymentMethodAdditional: {}
    },
    isThankYouPage: false,
    modifiedAt: 0
  }
```

Checkout 模块的状态包含[Order 对象 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/core/models/order.schema.json)并且在结帐过程由用户给定的，该信息被存储在进一步使用`localForage`。

状态由改性 [`placeOrder` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/1793aaa7afc89b3f08e443f40dd5c6131dd477ba/core/store/modules/checkout/actions.js#L11)行动和 [`load` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/1793aaa7afc89b3f08e443f40dd5c6131dd477ba/core/store/modules/checkout/actions.js#L41)其负载从浏览器的数据库的状态。

类别状态数据：

- `order`- 这是要放置的最后一个订单，[架构已定义 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/core/models/order.schema.json)符合 Ajv 格式
- `shippingDetails`, `paymentDetails`- 用户在[结账时](https://github.com/vuestorefront/vue-storefront/blob/master/core/pages/Checkout.vue)提供的地址信息[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/core/pages/Checkout.vue).

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#actions-3)行动

购物车商店提供以下公共操作：

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#placeorder-context-order)`placeOrder (context, { order })`

`Checkout.vue`为完成订单而调用的操作。根据[订单模式](https://github.com/vuestorefront/vue-storefront/blob/master/core/models/order.schema.json)验证数据对象[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/core/models/order.schema.json)，`localForage`通过后续调用存储在集合中[`order/placeOrder`（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/1793aaa7afc89b3f08e443f40dd5c6131dd477ba/core/store/modules/order/actions.js#L12)

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#savepersonaldetails-commit-personaldetails)`savePersonalDetails ({ commit }, personalDetails)`

存储个人详细信息（格式与此存储完全相同`state.personalDetails`）以供以后在浏览器的存储中使用

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#saveshippingdetails-commit-shippingdetails)`saveShippingDetails ({ commit }, shippingDetails)`

存储运输详细信息（格式与此存储完全相同`state.shippingDetails`）以供以后在浏览器的存储中使用

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#savepaymentdetails-commit-paymentdetails)`savePaymentDetails ({ commit }, paymentDetails)`

存储支付明细（格式与本店完全一致`state.paymentDetails`），供以后浏览器存储使用

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#load-commit)`load ({ commit })`

从加载当前状态 `localForage`

## [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#order-module)订单模块

该模块包含与订单操作相关的所有逻辑、组件和存储。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#components-4)成分

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#userorder)用户订单

**计算**

- `ordersHistory` - 映射值来自 `state.user.orders_history.items`
- `isHistoryEmpty`- 检查`state.user.orders_history.items`数组是否为空

**方法**

- `reorder (products)` - 遍历传递的“产品”数组，将每个项目添加到购物车
- `skipGrouped (items)` - 过滤器通过“items”数组，只返回不带的项目 `parent_id`

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#usersingleorder)用户单一订单

**计算**

- `ordersHistory` - 映射值来自 `state.user.orders_history.items`
- `order`- 在`orderHistory`计算属性中找到与路由`orderId`参数匹配的 id的顺序
- `paymentMethod`-`payment.additional_information[0]`从`order`计算属性返回
- `billingAddress`-`billing_address`从`order`计算属性返回
- `shippingAddress`-`extension_attributes.shipping_assignments[0].shipping.address`从`order`计算属性返回

**方法**

- `remakeOrder (items)` - 遍历传递的“items”数组，将每个项目作为单个产品添加到购物车
- `skipGrouped (items)` - 过滤器通过“items”数组，只返回不带的项目 `parent_id`

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#store-5)店铺

订单存储非常简单，用于将当前订单传递给后端服务。

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#actions-4)行动

订单商店提供以下公共操作：

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#placeorder-commit-order)`placeOrder ({ commit }, order)`

订单对象在本地 indexedDb 中排队等待`ordersCollection`发送到服务器。请查看[处理数据](https://docs.vuestorefront.io/v1/guide/data/data.html)以了解有关数据格式的详细信息以及`localForage`该项目中如何使用。

## [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#catalog-module)目录模块

Catalog 模块是一个很大的模块，它结合了属性、类别、产品、库存和税务操作的所有逻辑、组件和存储

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#components-5)成分

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#store-6)店铺

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#attribute-store)属性存储

属性存储旨在处理与属性管理相关的所有操作

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#state-4)状态

```js
  state: {
    list_by_code: {},
    list_by_id: {},
    labels: {}
  },
```

因为我们以与 Magento 非常相似的方式使用属性字典进行产品管理（[EAV 模型 （打开新窗口）](http://www.xpertdeveloper.com/2010/10/what-is-eav-model-in-magento/)) 我们正在对属性、属性类型和字典进行操作。

属性由用户通过调用方法**显式**加载`attribute/list`。例如，当您要处理产品的可自定义属性或处理变体时，您需要预取属性元数据：

```js
this.$store.dispatch('attribute/list', {
  filterValues: [true],
  filterField: 'is_user_defined',
});
```

这是[产品比较功能的](https://github.com/vuestorefront/vue-storefront/blob/c954b96f6633a201e10bed1d2e4c0def1aeb3071/core/pages/Compare.vue)示例[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/c954b96f6633a201e10bed1d2e4c0def1aeb3071/core/pages/Compare.vue).

属性状态数据：

- `list_by_code`- 这是一个字典，您可以通过访问`list_by_code['color']`等来获取特定属性。
- `list_by_id`- 这是一个字典，您可以通过访问`list_by_id[123]`等来获取特定属性。
- `labels` - 预加载的属性值标签（EAV 中的 V）

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#actions-5)行动

属性存储提供以下公共操作：

**`list (context, { filterValues = null, filterField = 'attribute_code', size = 150, start = 0 })`**

此方法用于加载属性元数据。`filterValues`就像多个值的阵列：`['color', 'size']`和`filterField`是属性字段来比较`filterValues`针对。通常是`attribute_code`或`attribute_id`。该`size`和`start`只是用来限制列表。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#getters-3)吸气剂

所有状态成员都应该只能由 getter 访问。请查看数据格式的状态参考

```js
export default {
  attributeListByCode: state => state.list_by_code,
  attributeListById: state => state.list_by_id,
};
```

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#category-store)品类商店

类别存储旨在处理与类别数据相关的所有操作。

该模块与 Elastic Search 紧密配合，并在[Product 数据格式上运行](https://docs.vuestorefront.io/v1/guide/data/elasticsearch.html)

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#state-5)状态

```js
const state = {
  list: [],
  current: {},
  filters: { color: [], size: [], price: [] },
  breadcrumbs: { routes: [] },
  current_path: [], // list of categories from root to current
};
```

类别状态通常仅由两个方法[列表](https://github.com/vuestorefront/vue-storefront/blob/06fbb89a5a8bc2c607847f65a7bca9ad54ed7146/core/store/modules/category.js#L38)填充[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/06fbb89a5a8bc2c607847f65a7bca9ad54ed7146/core/store/modules/category.js#L38)和[单身 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/06fbb89a5a8bc2c607847f65a7bca9ad54ed7146/core/store/modules/category.js#L70)并通过[重置](https://github.com/vuestorefront/vue-storefront/blob/06fbb89a5a8bc2c607847f65a7bca9ad54ed7146/core/store/modules/category.js#L28)清除为默认值[（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/06fbb89a5a8bc2c607847f65a7bca9ad54ed7146/core/store/modules/category.js#L28)

笔记

该操作仅`category/single`使用`localForage`缓存 - 不直接存储 ElasticSearch 数据；由于此优化，请`category/list`首先通过调度下载类别列表。

类别状态数据：

- `breadcrumbs`- 这是[面包屑组件](https://github.com/vuestorefront/vue-storefront/blob/master/core/components/Breadcrumbs.js)使用的路由列表[（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/core/components/Breadcrumbs.js)
- `current` - 这是当前的类别对象，
- `filters`是类别过滤器的当前状态 - 所选变体属性的字典；例如，它包含选定产品属性的字典：

```json
{
  "color": 123,
  "size": 24
}
```

请注意，我们使用的是 Magento 之类的 EAV 属性结构 - 所以这里的值是属性值索引而不是值本身。请查看[数据格式](https://docs.vuestorefront.io/v1/guide/data/elasticsearch.html)以供参考

- `current_path` - 这是类别对象的列表：从当前类别到顶级根，

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#events-3)活动

以下事件是从`category`商店发布的：

- `EventBus.$emit('category-after-single', { category: mainCategory })`- 从[类别/单 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/06fbb89a5a8bc2c607847f65a7bca9ad54ed7146/core/store/modules/category.js#L70)加载单个类别后，
- `EventBus.$emit('category-after-current', { category: category })`- 当前类别更改后 - 这是后续`category/single`行动呼吁，
- `EventBus.$emit('category-after-reset', { })` - 类别重置后（例如在从一个类别页面移动到另一个类别的过程中）
- `EventBus.$emit('category-after-list', { query: qrObj, sort: sort, size: size, start: start, list: resp })`- 此事件发出当前类别列表，因为它由`category/list`.

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#actions-6)行动

购物车商店提供以下公共操作：

**`list (context, { parent = null, onlyActive = true, onlyNotEmpty = false, size = 4000, start = 0, sort = 'position:asc' })`**

这是加载类别列表的关键方法。它返回`Promise`包含产品列表对象的 。这种方法应该在您需要获取产品数据的任何地方使用。

**`single (context, { key, value, setCurrentCategory = true, setCurrentCategoryPath = true })`**

此方法从`localForage`.

重要的

要使此方法起作用，您应该先调用`category/list`。该分类只对localFotage有效，不能直接访问ElasticSearch

重要的

此方法通过以下方式同步产品以供离线使用：将整个查询结果对象存储到`localForage`并单独缓存每个类别（例如在产品页面上使用）

此方法发出类别列表为 `EventBus.$emit('category-after-list', { query: qrObj, sort: sort, size: size, start: start, list: resp })`

- `parent`-`category`仅加载子类别的对象
- `start`, `size`- 两个参数都用于分页；start 是起始索引；size 是页面大小
- `onlyActive` - (bool) 仅加载 CMS 中标记为活动的类别（例如在 Magento 中）
- `sort` - 用于排序的类别属性，此字段必须在 ElasticSearch 中映射为数字字段
- `onlyNotEmpty` - (bool) 仅加载包含任何产品的类别

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#getters-4)吸气剂

所有状态成员都应该只能由 getter 访问。请查看数据格式的状态参考

```js
const getters = {
  current: state => state.current,
  list: state => state.list,
};
```

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#product-store)产品商店

Product Store 旨在处理与产品数据相关的所有操作。它负责加载产品列表或单个产品以及配置可配置产品和管理产品附件。

该模块与 Elastic Search 紧密配合，并在[Product 数据格式上运行](https://docs.vuestorefront.io/v1/guide/data/elasticsearch.html)

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#state-6)状态

```js
const state = {
  breadcrumbs: { routes: [] },
  current: null, // shown product
  current_options: { color: [], size: [] },
  current_configuration: {},
  parent: null,
  list: [],
  original: null, // default, not configured product
  related: {},
};
```

产品状态通常仅由两种方法[列表](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L395)填充[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L395)和[单身 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L428)并通过[重置](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L215)清除为默认值[（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L215)

产品状态数据：

- `breadcrumbs`- 这是[面包屑组件](https://github.com/vuestorefront/vue-storefront/blob/master/core/components/Breadcrumbs.js)使用的路由列表[（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/core/components/Breadcrumbs.js)
- `current`- 这是具有选定`configurable_children`变体的产品对象- 因此它是基本产品，其属性被选定`configurable_children`变体的值覆盖；它在[Product.vue 页面](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/pages/Product.vue#L203)上使用[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/pages/Product.vue#L203)这是在“加入购物车”后加入购物车的产品
- `current_options`- 它是一个列表，用于填充[Product.vue 页面](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/themes/default/pages/Product.vue#L56)上的变体选择器[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/themes/default/pages/Product.vue#L56)它包含属性 x 可能的属性值和标签的字典，并由[setupVariants](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L344)填充[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L344)根据`configurable_children`财产
- `current_configuration`是当前产品配置 - 所选变体属性的字典；例如，它包含选定产品属性的字典：

```json
{
  "color": 123,
  "size": 24
}
```

请注意，我们使用的是 Magento 之类的 EAV 属性结构 - 所以这里的值是属性值索引而不是值本身。请查看[数据格式](https://docs.vuestorefront.io/v1/guide/data/elasticsearch.html)以供参考

- `parent`- 如果当前产品是一个，`type_id="single"`则在这个变量`configurable`中存储父产品。此数据仅`Product.vue`由[checkConfigurableParent](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L323)填充[（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L323)
- `list`- 这是一个[列表](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L395)加载的产品数组[（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L395)
- `original`- 仅用于`configurable`产品；这是未选择变体的基础产品
- `related`- 这是相关产品的字典；设置在这家商店外（[例如这里 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/src/themes/default/components/core/blocks/Product/Related.vue)) 通过调用和[相关操作（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L528)

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#events-4)活动

以下事件是从`product`商店发布的：

- `EventBus.$emit('product-after-priceupdate', product)`- 来自[同步产品价格 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bd559f1baad7cd392bc5bae7b935a60484e2e6e5/src/store/modules/product.js#L33)产品价格与Magento同步后；
- `EventBus.$emit('product-after-configure', { product: product, configuration: configuration, selectedVariant: selectedVariant })`from `configureProductAsync`（由`product/configure`之后的动作调用`product/single`）。此事件在产品页面上提供有关所选产品变体的信息
- `EventBus.$emit('product-after-list', { query: query, start: start, size: size, sort: sort, entityType: entityType, result: resp })`- 此事件通过`product/list`提供当前过滤器等返回当前产品列表。您可以通过设置`meta`属性来标记特定的产品列表标识符；这很重要，因为在单个页面上，此事件可以针对每个单独的产品块执行多次
- `EventBus.$emit('product-after-single', { key: key, options: options, product: cachedProduct })`- 加载单个产品后（由`product/single`操作调用）
- `EventBus.$emit('product-after-related', { key: key, items: items })`- 每当为当前产品设置相关产品块时调用；key 是相关块的名称，items 是相关产品
- `EventBus.$emit('product-after-original', { original: product })`-`product/single`每当产品加载时调用
- `EventBus.$emit('product-after-parent', { parent: product })`- 通过`product/checkConfigurableParent`提供当前的单个产品可配置父级从外部调用
- `EventBus.$emit('product-after-reset', { })` - 产品重置后（例如在从一个产品页面移动到另一个页面的过程中）

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#actions-7)行动

产品商店提供以下公共操作：

**`setupBreadcrumbs (context, { product })`**

该方法负责页面`state.breadcrumbs`上要使用的设置`Product.vue`。它是从 调用的`Product.vue:fetchData`。所述`product`参数是一个[ElasticSearch产品对象](https://docs.vuestorefront.io/v1/guide/data/elasticsearch.html)

**`syncPlatformPricesOver(context, { skus })`**

当 config 选项`products.alwaysSyncPlatformPricesOver`打开时，Vue Storefront 将在每次调度`product/single`或`product/list`操作时请求当前产品价格。它由这些操作专门调用，不应手动调用。此方法调用`vue-storefront-api`代理从 Magento 或任何其他后端 CMS 获取当前价格。

`skus` - 这是一个包含要同步的产品 SKU 的数组

**`setupAssociated (context, { product })`**

此方法被称为后续调用`Product.vue:fetchData`或`product/list`操作。它用于获取子产品`grouped`或`bundle`产品类型。

**`checkConfigurableParent (context, {product})`**

调用此方法`Product.vue:fetchData`以检查当前的简单产品是否具有可配置的父级。如果是这样，则重定向到父产品。这是[#508](https://github.com/vuestorefront/vue-storefront/issues/508)的修复[（打开新窗口）](https://github.com/vuestorefront/vue-storefront/issues/508)

**`setupVariants (context, { product })`**

此方法随后被调用`Product.vue:fetchData`以加载 中定义的所有可配置属性`product.configurable_options`，然后填充`state.current_configuration`和`state.current_options`。此动作的主要用途是在产品页面上准备由用户配置的产品，并正确显示产品配置器 UI

**`list (context, { query, start = 0, size = 50, entityType = 'product', sort = '', cacheByKey = 'sku', prefetchGroupProducts = true, updateState = true, meta = {} })`**

这是加载产品列表的关键方法。它返回`Promise`包含产品列表对象的 。这种方法应该在您需要获取产品数据的任何地方使用。当`config.tax.calculateServerSide=false`此方法运行产品税计算器并根据需要与 Magento 同步价格时。

此方法将产品列表作为 `EventBus.$emit('product-after-list', { query: query, start: start, size: size, sort: sort, entityType: entityType, meta: meta, result: resp })`

重要的

此方法通过以下方式同步产品以供离线使用：将整个查询结果对象存储到`localForage`并单独缓存每个产品（例如在产品页面上使用）

- `query`- 这是`bodybuilder`ElasticSearch 查询（请检查`bodybuilder`包或例如`Home.vue`参考如何使用它）
- `start`, `size`- 两个参数都用于分页；start 是起始索引；size 是页面大小
- `entityType`- 默认情况下，它当然设置为`product`并映射到 ElasticSearch 实体类
- `sort` - 用于排序的产品属性，此字段必须在 ElasticSearch 中映射为数字字段
- `prefetchGroupProducts`- 默认情况下它设置为 true 并导致`setupAssociated`分派操作以获取所有相关产品
- `updateState`- 如果您将此设置为 false，`state.list`则不会更新 - 只会退回产品
- `meta`- 这是一个与`product-after-list`事件一起返回的可选属性；例如，它可以用于标记任何特定的 ES 调用。

**`single (context, { options, setCurrentProduct = true, selectDefaultVariant = true, key = 'sku' })`**

此方法随后调度`product/list`操作以获取产品并同步税金/价格。当最近通过`product/list`此方法下载产品时，将从中返回缓存版本`localForage`- 但无论如何都要更新缓存。

**`configure (context, { product = null, configuration, selectDefaultVariant = true })`**

此操作用于配置`configurable`具有指定属性的产品。它获取`configuration`应具有以下格式的对象：`{ attribute_code: attribute_value_id }`并找到`product.configurable_children`符合此配置的项目。然后它将这个特定的`configurable_child`与产品本身合并- 例如将 product.price 设置为可配置的价格、颜色、尺寸等。该方法用于：`Product.vue`允许用户选择颜色、尺寸等的页面。它的第二个用法是`Category.vue`页面 - 在用户选择一些过滤器后，生成的产品被配置为显示正确的图像（与所选颜色和尺寸相关）和价格。

如果`selectDefaultVariant`设置为 true（默认），`state.current`则将根据配置的产品进行更改。

**`setCurrent (context, productVariant)`**

辅助方法只是设置`state.current`为 productVariant

**`setOriginal (context, originalProduct)`**

辅助方法只是设置`state.original`为 originalProduct

**`related (context, { key = 'related-products', items })`**

更改`state.related`字典以设置要在`Product.vue`页面上显示的相关产品的特定列表（`RelatedProducts`组件用于此）

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#getters-5)吸气剂

所有状态成员都应该只能由 getter 访问。请查看数据格式的状态参考

```js
const getters = {
  productParent: state => state.parent,
  productCurrent: state => state.current,
  currentConfiguration: state => state.current_configuration,
  productOriginal: state => state.original,
  currentOptions: state => state.current_options,
  breadcrumbs: state => state.breadcrumbs,
};
```

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#stock-store)库存商店

Stock Store 旨在处理库存数量检查。

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#events-5)活动

以下事件是从`stock`商店发布的：

- `stock-after-check` - 在从电子商务后端/ Magento 收到库存商品后立即发出

##### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#actions-8)行动

购物车商店提供以下公共操作：

**`check (context, { product, qty = 1 })`**

检查是否`product`可以将给定数量的商品添加到购物车中。

生成的 promise 扩展为以下对象：

```js
{
  qty: 100,
  status: 'ok', // another option is: 'out_of_stock'
  onlineCheckTaskId: 14241
}
```

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#tax-store)税务商店

### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#helpers)帮手

#### [#](https://docs.vuestorefront.io/v1/guide/archives/modules.html#optionlabel)选项标签

用于获取特定 的标签`optionId`。例如，当用户过滤产品并使用 165 个 attribute_value 时，我们可以调用`optionLabel( { attributeKey: 'color', optionId: 165 })`以取回 'Red' 标签。

