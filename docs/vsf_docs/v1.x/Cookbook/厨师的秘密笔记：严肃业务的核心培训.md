# 厨师的秘密笔记：严肃业务的核心培训

指导

这本食谱没有食谱，但在将*VSF*投入生产之前为您提供了一个清单。您可以与您的实例进行比较，一一勾选列表，以便让您的*餐厅*为*米其林检查*做好准备。

在本章中，我们将介绍：



- [0. 介绍](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_0-introduction)
- [1. 内存泄漏](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-memory-leaks)
- [2. SSR 输出缓存](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-ssr-output-cache)
- [3. 避免价格不同步](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_3-avoiding-prices-desynchronization)
- [4. 避免库存不同步](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_4-avoiding-stock-desynchronization)
- [5. Vue Storefront 如何计算价格和税收](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_5-how-vue-storefront-calculates-prices-and-taxes)
- [6. 限制 SSR HTML 大小，即 INITIAL_STATE 优化](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_6-limiting-ssr-html-size-a-k-a-initial-state-optimization)
- [7. Url Dispatcher 解释](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_7-url-dispatcher-explained)
- [8. Multistore 配置说明](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_8-multistore-configuration-explained)
- [9. HTML 最小化、压缩、标题](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_9-html-minimization-compression-headers)
- [10.生产目录索引+缓存失效](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_10-production-catalog-indexing-cache-invalidation)
- [11. 使用 Magento Checkout](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_11-using-magento-checkout)
- [12. Elasticsearch 生产设置](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_12-elasticsearch-production-setup)
- [13. .htaccess、服务器端重定向、HTTP 代码和标头、中间件](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_13-htaccess-server-side-redirects-http-codes-and-headers-middlewares)
- [14. VSF 真正使用的产品、类别和属性的哪些字段](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_14-which-fields-of-product-category-and-attribute-are-really-used-by-vsf)
- [15. 配置文件属性中非常方便的功能](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_15-quite-handy-features-in-config-file-properties)
- [16. Cloudflare 自动清除](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_16-cloudflare-autopurge)
- [17. VSF 缓存清漆](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_17-vsf-cache-varnish)
- [18.VSF缓存NGINX](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_18-vsf-cache-nginx)
- [19. 适用于 Magento 1 和 Magento 2 的 Vue Storefront 1 配置验证器](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_19-vue-storefront-1-config-validator-for-magento-1-and-magento-2)
- [20. 一个示例主题开始](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_20-a-sample-theme-to-start-with)
- [21、针对Vue Storefront 1开发优化Webpack配置](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_21-optimized-webpack-configuration-for-vue-storefront-1-development)
- [22. 在 VSF 1.12+ 中摆脱 depracatedActions](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_22-get-rid-of-depracatedactions-in-vsf-1-12)



安全最佳实践

有一个专门用于 PWA 安全的单独站点，您可以从行业专家那里获得一些建议来申请您的业务。 [无头安全最佳实践（打开新窗口）](https://headless-security.org/vsf-best-practices.html)

## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_0-introduction)0. 介绍

Vue Storefront 得到了市场的极大关注，并得到了开发人员的青睐，拥有 20 多个生产站点。与此同时，Vue Storefront 框架随着每个新版本的发布而发展，文档几乎跟不上它！

这些培训材料是一套主要配方，从战壕中学到的经验。我试图回答如何在生产环境中运行 Vue Storefront，解决大多数常见问题并解释 Vue Storefront 的所有隐藏功能，这些功能可以帮助您扩展应用程序并解决大多数常见问题。

这里的一些主题摘自[我们论坛中的常见问题 （打开新窗口）](https://forum.vuestorefront.io/c/help). 有些[来自 Slack （打开新窗口）](http://slack.vuestorefront.io/). 有些来自核心咨询和我们自己的工作。一件事是共同的；每一个配方对于在生产环境中稳定运行的 Vue Storefront 都非常关键，如果不小心执行它们都会导致一些严重的结果。

## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-memory-leaks)1. 内存泄漏

Vue Storefront 由两个 Node.js 应用程序组成：

- `vue-storefront` - 这是前端应用程序，入口点为 [`core/scripts/server.js`（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/4ed26d7f1978a9e798edcddf1cf2f970c3e64e4f/core/scripts/server.js#L269)
- `vue-storefornt-api` - 这是后端/api 应用程序。

如果您熟悉 PHP Web 应用程序并在生产环境中运行 PHP，无论是 fastCGI 还是 FPM，*Node.js 的*工作方式都完全不同。它不是`node`针对每个请求执行进程，而是运行一个内部 http 服务器来为所有后续请求提供服务。它是单线程、长时间运行的任务。这就是为什么很容易陷入内存泄漏问题的原因；特别是对于`vue-storefront`比 API 复杂得多的应用程序。

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#protip)专家提示

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-first-thing-first-monitor-memory-leaks)1. 首先，监控内存泄漏

你怎么知道你有内存泄漏卧底？

从 Vue Storefront 根目录开始`yarn pm2 status`或`yarn pm2 monit`获取详细信息。

该`pm2` [内存使用情况 （打开新窗口）](http://pm2.keymetrics.io/docs/usage/monitoring/)随着每次页面刷新而增长。

*PM2*在[1GB RAM](https://github.com/vuestorefront/vue-storefront/blob/master/ecosystem.json#L5)后重新启动进程[（默认情况下） （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/ecosystem.json#L5)正在使用中；这可以调整，并与`instances`在 中设置的多个节点一起`ecosystem.json`，这是内存泄漏的一个很好的解决方法。

此外，有很多方法可以跟踪内存泄漏，但是我们大部分时间都在使用浏览器工具（内存配置文件）。[在这里你有详细的解释 （打开新窗口）](https://marmelab.com/blog/2018/04/03/how-to-track-and-fix-memory-leak-with-nodejs.html). 另一个有用的工具是[New Relic APM （打开新窗口）](http://newrelic.com/)和[谷歌跟踪（打开新窗口）](https://cloud.google.com/trace/docs/setup/nodejs)

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-how-to-use-vue-plugins)2.如何使用Vue插件

您必须避免的一件事是`Vue.use`多次使用，您可以通过始终在 inside 调用它来确保它`once`。在 Vue Storefront 代码中，你经常可以找到这样的片段：

```js
import { once } from '@vue-storefront/core/helpers'
once('__VUE_EXTEND_RR__', () => {
  Vue.use(VueRouter)
})
```

这是一个**帮助**您安全使用插件的助手。随意将它与所有插件和 mixins 实例化一起使用。

进一步研究

Vue.js 文档中有关于[如何避免 Vue.js 内存泄漏的](https://vuejs.org/v2/cookbook/avoiding-memory-leaks.html)很好的部分[ （打开新窗口）](https://vuejs.org/v2/cookbook/avoiding-memory-leaks.html).

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_3-handling-events-in-a-proper-way)3.以适当的方式处理*事件*

另一件事是正确处理事件。每个`EventBus.$on`必须有其对应的`EventBus.$off`. 您应该在其生命周期中小心地打开和关闭它们。

其次，请尽量避免**在`created`hook中绑定事件的** 情况。在`created`被称为纯英文的SSR模式或服务器端; 但是，如果您绑定`beforeMount`它，它将仅在 CSR（代表客户端渲染或简单的客户端浏览器）中执行，这是 99% 所需的行为，并且您不会冒事件发生内存泄漏的风险。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_4-stateful-singleton)4. 有状态单例

确保您已`runInNewContext`设置为`true`（默认值！）[`core/scripts/utils/ssr-renderer.js` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/master/core/scripts/utils/ssr-renderer.js#L16).

通过设置`false`，[Stateful Singletons （打开新窗口）](https://github.com/vuestorefront/vue-storefront/issues/2664)喜欢`RouteManager`或`i18n`我们正在使用将导致 huuuuuge 规模的内存泄漏。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_5-static-pages-generator)5. 静态页面生成器

我们确实有**静态页面生成器**- 目前是实验性功能 - 可以将整个站点生成为一组静态 HTML 文件，因此它们甚至可以直接从云提供商/CDN 提供服务 - 不可能出现内存泄漏；在此模式下您需要处理的是缓存失效（当前不支持但易于添加）。[阅读有关静态页面生成器的更多信息 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/pull/3256).

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_6-learn-from-core-team)6. 向核心团队学习

如果您想深入挖掘与内存泄漏相关的任何问题，请[了解核心团队如何处理内存泄漏 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/pulls?utf8=✓&q=is%3Apr+memory+is%3Aclosed+leak)在 Vue Storefront 核心中 - 并检查解决的任何边缘案例是否可以为您的项目提供灵感。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-ssr-output-cache)2. SSR 输出缓存

Vue Storefront 支持[服务端渲染 （打开新窗口）](https://vuejs.org/v2/guide/ssr.html). 在这种模式下，在浏览器（CSR；客户端渲染）中执行的相同代码在服务器上运行以生成 HTML 标记。然后，标记被传输到浏览器，呈现（非常快，因为浏览器都经过优化......在过去 20 多年中呈现 html 文本）并[水合 （打开新窗口）](https://ssr.vuejs.org/guide/hydration.html)从[初始状态 （打开新窗口）](https://ssr.vuejs.org/guide/data.html#final-state-injection). 在整个过程中，客户端或浏览器脚本可以普遍使用完全相同的代码库。另一个很酷的功能是静态 HTML 标记被搜索引擎爬虫很好地索引，这对 SEO 非常重要。

通常，Vue Storefront 的运行速度非常快，所有 SSR 请求都在 100-300 毫秒之间完成；但是，如果您的数据库很大或您的服务器资源很少，或者流量可能非常高，您可能需要启用输出缓存。另一个原因是你可能想使用 SSR 缓存来防止内存泄漏，或者我应该说，隐藏它们😉。

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#protip-2)专家提示

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-ssr-cache-docs)1. SSR 缓存文档

SSR 缓存[在我们的文档中有很好的记录](https://docs.vuestorefront.io/v1/guide/basics/ssr-cache.html)。什么是重要的；它适用于：`vue-storefront`和`vue-storefront-api`。

[阅读所有缓存机制 （打开新窗口）](https://medium.com/the-vue-storefront-journal/caching-on-production-10b00a5614f8)Vue Storefront 正在使用的那个。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-using-redis-tagging)2. 使用Redis标签

启用 SSR 输出缓存模式后， [`core/server.js` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/scripts/server.js#L187)将渲染的输出页面与 http 标头一起存储到 Redis 缓存中。如果页面存在于 Redis 中，那么它甚至不需要启动 Vue SSR 渲染器就可以得到服务。

Vue Storefront 使用 Redis 来使用 [`redis-tagging` （打开新窗口）](https://www.npmjs.com/package/redis-tagging)图书馆。命名和缓存是软件开发中两个最困难的领域。缓存标记帮助我们处理缓存失效。

Vue Storefront 使用[产品](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/modules/catalog/helpers/search.ts#L69)标记输出页面[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/modules/catalog/helpers/search.ts#L69)和[类别 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/modules/catalog/store/category/actions.ts#L121)标签。然后所有索引器包括：`magento1-vsbridge-indexer`，`mage2vuestorefront`并且`magento2-vsbridge-indexer`将根据特定*产品*或*类别* *ID*使缓存无效。这意味着[`invalidate` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/scripts/server.js#L156)方法将清除标记有此特定*产品 id*的缓存页面。

笔记

此 URL 要求您传递[配置中](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/config/default.json#L12)设置的失效令牌[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/config/default.json#L12).

您可以添加任意数量的特定缓存标签 - 只需扩展 [`availableCacheTags` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/config/default.json#L11)和/或[将标签推送到`ssrContext` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/pages/Home.js#L19)所以它们可以被`core/scripts/server`.

`context`传递给的这个参数`asyncData()`实际上是被使用的同一个上下文对象[`core/scripts/server.js` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/scripts/server.js#L168)，所以我们将它用作传输对象，用于在服务器和 Vue.js 应用程序之间来回传递标签。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_3-invalidating-ssr-cache)3. 使 SSR 缓存失效

笔记

随着SSR缓存开启（`vue-storefront-api`或`vue-storefront`应用），请确保你使用的不是不同层（例如清漆或nginx的）上的高速缓存。否则缓存失效机制将不起作用。

动态标签配置选项：`useOutputCacheTagging`- 如果设置为`true`，Vue Storefront 会生成特殊的 HTTP 标头`X-VS-Cache-Tags`

```js
res.setHeader('X-VS-Cache-Tags', cacheTags);
```

缓存标签是根据特定页面上使用的产品和类别分配的。一个典型的`X-VS-Cache-Tags`标签如下所示：

```text
X-VS-Cache-Tags: P1852 P198 C20
```

如果使用 Varnish 缓存，这些标签可用于使其无效。[阅读更多 （打开新窗口）](https://www.drupal.org/docs/8/api/cache-api/cache-tags-varnish).

笔记

所有官方 Vue Storefront 数据索引器，包括[magento1-vsbridge-indexer （打开新窗口）](https://github.com/divanteLtd/magento1-vsbridge-indexer)和[magento2-vsbridge-indexer （打开新窗口）](https://github.com/vuestorefront/magento2-vsbridge-indexer)支持缓存失效。

如果在 API 和 Vue Storefront 前端应用程序中都启用了缓存，请确保正确使用`config.server.invalidateCacheForwardUrl`config 变量，因为索引器只能将缓存无效请求发送到一个 URL（前端或后端），并且**应该转发**到另一个. 请检查 中的默认转发 URL`default.json`并将`key`参数调整为 的值`server.invalidateCacheKey`。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_3-avoiding-prices-desynchronization)3. 避免价格不同步

Vue Storefront 索引器 ( `magento2-vsbridge-indexer`, `magento1-vsbridge-indexer`, `mage2vuestorefront`) 都将产品价格（应用目录规则之前/之后）存储到 Elasticsearch 中。但是 Elasticsearch 很容易不同步或同步可能滞后。为了避免向客户显示错误价格的风险，Vue Storefront 至少有 3 种机制——`alwaysSyncPlatformPricesOver`在顶部。

笔记

如果您使用`mage2vuestorefront`来同步产品，请确保在应用**目录规则后**同步价格。为此，我们要设置特殊标志：

```bash
export PRODUCTS_SPECIAL_PRICES=true
export PRODUCTS_RENDER_PRICES=true
node --harmony cli.js products --removeNonExistent=true --partitions=1
```

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#protip-3)专家提示

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-alwayssyncplatformpricesover-to-be-in-sync)1. *alwaysSyncPlatformPricesOver*保持同步

当该`config.products.alwaysSyncPlatformPricesOver`选项打开时，Vue Storefront 将**直接从源网络商店（例如 Magento ）**更新所有列表和产品详细信息页面上的可见价格。（Magento 代表以下源网络商店）负责此操作的代码位于[`doPlatformPricesSync` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/core/modules/catalog/helpers/index.ts#L212)从调用的助手 [`tax/calculateTaxes` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/core/modules/catalog/store/tax/actions.ts#L74)行动。

笔记

每当在服务器端或客户端（`config.tax.calculateServerSide`选项）计算价格时，此模式都有效。

检查[Vue Storefront同步价格的方式 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/core/modules/catalog/helpers/index.ts#L216)正是您所需要的，而不是[覆盖此操作 （打开新窗口）](https://docs.vuestorefront.io/guide/cookbook/module.html#_2-2-recipe-b-override-vuex-store-with-extendstore).

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-alwayssyncplatformpricesover-has-2-options)2. *alwaysSyncPlatformPricesOver*有 2 个选项

该`alwaysSyncPlatformPricesOver`模式有两个附加选项：

1. 同步前清除价格：`config.products.clearPricesBeforePlatformSync`- 当设置为 时`true`，用户在从 Magento 获取新价格之前不会看到缓存在 Elasticsearch 中的价格
2. 同步模式 -`config.products.waitForPlatformSync`默认情况下，价格同步与显示产品或类别内容并行运行，即*异步*。我们可以使其同步（等待此过程完成），以便在 HTML 标记（SSR；否则 SSR 中的价格将来自 Elasticsearch）中呈现 Magento 的当前价格。

更重要的是 - Vue Storefront 总是从 Magento 或任何其他后端获取**平台总计**（购物车和订单摘要中可见的最终价格）。这样您的客户就没有风险看到价格不正确的产品。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_4-avoiding-stock-desynchronization)4. 避免库存不同步

与产品库存的价格几乎相同的情况。默认情况下，所有索引器都将[股票信息正确](https://github.com/vuestorefront/vue-storefront-integration-sdk/blob/tutorial/Format-product.md)设置[到产品对象中 （打开新窗口）](https://github.com/vuestorefront/vue-storefront-integration-sdk/blob/tutorial/Format-product.md)如下 ：

- 在主要结构中 `product.stock`
- 在`product.configurable_children.stock`为`configurable_children`。

这些信息可能已经过时。

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#protip-4)专家提示

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-how-it-stays-in-sync-in-real-time)1.如何保持实时同步

**在以下情况下，** Vue Storefront**默认**检查当前库存信息：

- [**用户将产品添加到购物车** （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/core/modules/cart/store/actions/itemActions.ts#L53)- 这是一个异步过程（在浏览产品变体时运行类似的过程 - 您可以获得`0 items available`切换颜色和尺寸时的信息）；`Checkout.js`正在等待所有结果[`stock/queueCheck` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/core/pages/Checkout.js#L69)调用。
- 当**购物车**与服务器**同步**时 - 电子商务后端[再次检查产品可用性 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/core/modules/cart/store/actions/mergeActions.ts#L45)并[通知用户 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/core/modules/cart/components/AddToCart.ts#L31)如果产品无法添加到购物车或恢复之前的数量（如果更改）。
- 当`filterOutUnavailableVariants`模式打开并且用户 a) 进入产品页面，b) 浏览类别页面时。

该`config.products.filterOutUnavailableVariants`模式是非常重要的，因为只有具备这种模式下你切换可以确保我们**不显示不可用的变体**。当它设置为`true`Vue Storefront时，会将库存信息从 Magento 中取出并更新`product.stock`整个产品列表 + 产品页面（当前产品）的信息。然后它删除所有`configurable_children`不可用的。[查看详细实现 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/core/modules/catalog/helpers/index.ts#L121).

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-additional-options)2. 附加选项

此模式有两个附加设置：

- `config.products.configurableChildrenStockPrefetchStatic`- 在这种情况下`true`，Vue Storefront 为静态设置的产品数量预取库存信息，可以通过`config.products.configurableChildrenStockPrefetchStaticPrefetchCount`.
- `config.products.configurableChildrenStockPrefetchDynamic`- 设置为 true 时，Vue Storefront 会预取任何可见产品的库存信息；它是在[`ProductTile.vue` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/src/themes/default/components/core/ProductTile.vue#L108)- 确保您的主题支持这一点。

我们在默认实现中对 Magento MSI 的支持有限。[确保在 Magento 2.3.x 上启用它 （打开新窗口）](https://github.com/vuestorefront/vue-storefront-api/pull/226).

笔记

此功能随后可用于与[提示 2-SSR 缓存](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-ssr-output-cache)相关的**Donut 缓存**策略。

笔记

如果您想绕过 Magento 股票调用，有一种方法可以获取与`https://vue-storefront-api/api/stock/list`返回数据格式相同但来自 Elasticsearch 的数据。它应该是一个替代品 - 我的意思是[改变`stock.endpoint` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/bb9044d6aaa36d4881733876f4646fabe7b6e102/config/default.json#L368)到这个新的。等等：你跳过询问 Magento，仍然有这个“缓存打孔”`config.products.filterOutUnavailableVariants`模式

有一个现成的端点可以从 Elasticsearch（不是从 Magento）获取股票[在这里#PR330 （打开新窗口）](https://github.com/vuestorefront/vue-storefront-api/pull/330).

故障排除

如果不存在的变体不会消失，则意味着您需要完成一些前端工作。

我的意思是 - 通过这个`filterOutUnavailableVariants`设置，我们将当前的股票信息拉到`product.stock`和`product.configurable_children.stock`属性。随着这些属性的更新，我们将删除脱销的`configurable_children`. 如果变体仍然可用，[请查看此行 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/48233bfa4575be218a51cccd2474ec358671fc01/core/modules/catalog/store/product/actions.ts#L629)应该有一个改变

从：

```js
if (isServer) {
  subloaders.push(context.dispatch('setupBreadcrumbs', { product: product }))
  subloaders.push(context.dispatch('filterUnavailableVariants', { product: product }))
} else {
  attributesPromise.then(() => context.dispatch('setupBreadcrumbs', { product: product })) // if this is client's side request postpone breadcrumbs setup till attributes are loaded to avoid too-early breadcrumb switch #2469
  context.dispatch('filterUnavailableVariants', { product: product }) // exec async
}
```

到：

```js
  subloaders.push(context.dispatch('filterUnavailableVariants', { product: product }))
if (isServer) {
  subloaders.push(context.dispatch('setupBreadcrumbs', { product: product }))
} else {
  attributesPromise.then(() => context.dispatch('setupBreadcrumbs', { product: product })) // if this is client's side request postpone breadcrumbs setup till attributes are loaded to avoid too-early breadcrumb switch #2469
}
```

只是为了确保在呈现 PDP（产品详细信息页面）之前始终进行属性过滤。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_5-how-vue-storefront-calculates-prices-and-taxes)5. Vue Storefront 如何计算价格和税收

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#protip-5)专家提示

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-two-modes-for-tax-calculation)1. 两种计税方式

Vue Storefront 有两种计算产品价格的模式：

- 客户端（`config.tax.calculateServerSide`设置为 时`false`）- 如果应根据地址更改重新计算税款，这可能很有用。
- 服务器端（`config.tax.calculateServerSide`设置为 时`true`） - 这是默认设置。

根据模式，税由[`taxCalc.ts`客户端计算 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/5f2b5cd6a8496a60884c091e8509d3b58b7a0358/core/modules/catalog/helpers/taxCalc.ts#L74)或[`taxcalc.js`服务器端 （打开新窗口）](https://github.com/vuestorefront/vue-storefront-api/blob/d3d0e7892cd063bbd69e545f3f2b6fdd9843d524/src/lib/taxcalc.js#L251-L253).

您可能会看到这两个文件应用**完全相同**的逻辑。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-factors-considered-for-tax-rate)2. 税率考虑因素

为了计算价格和税收，我们首先需要获得适当的税率。它基于[`taxrate` （打开新窗口）](https://github.com/vuestorefront/vue-storefront-integration-sdk#taxrate-entity)实体，存储在 Elasticsearch 中。每个产品都可以有属性[`product.tax_class_id` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/5f2b5cd6a8496a60884c091e8509d3b58b7a0358/core/modules/catalog/helpers/taxCalc.ts#L213)放。根据其价值，Vue公司店面应用`taxrate`及[国家和地区的过滤器 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/5f2b5cd6a8496a60884c091e8509d3b58b7a0358/core/modules/catalog/helpers/taxCalc.ts#L226).

笔记

我们目前不支持通过搜索既不是税收规则`customer_tax_class_id`，也不`tax_postcode`领域`taxrate`实体。非常欢迎拉取请求 😉

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_3-calculation)3. 计算

获得正确的税率后，我们可以计算价格。

我们在 VSF 中优先考虑了以下价格字段：

- `final_price`- 如果设置，取决于`config.tax.finalPriceIncludesTax`- 它被视为最终价格或净最终价格，
- `special_price`- 如果它被设置并且低于`price`它将替换`price`并且该`price`值将被设置到`original_price`属性中，
- `price`- 如果设置，取决于`config.tax.sourcePriceIncludesTax`- 它被视为最终价格或净最终价格。

根据`config.tax.finalPriceIncludesTax`和`config.tax.sourcePriceIncludesTax`设置，Vue Storefront 计算价格并将其存储到以下字段中。

产品特价：

- `special_price` - 可选，如果设置 - 它总是净价，
- `special_price_incl_tax` - 可选，如果设置 - 它总是税后价格，
- `special_price_tax` - 可选，如果设置为税额。

产品正常价格：

- `price` - 需要，如果设置 - 它总是净价，
- `price_incl_tax` - 需要，如果设置 - 它总是税后价格，
- `price_tax` - 必填，如果设置为税额，

产品最终价格：

- `final_price` - 可选，如果设置 - 它总是净价，
- `final_price_incl_tax` - 可选，如果设置 - 它总是税后价格，
- `final_price_tax` - 可选，如果设置为税额，

产品原价（仅当`final_price`或`special_price`低于 时设置`price`）：

- `original_price` - 可选，如果设置 - 它总是净价，
- `original_price_incl_tax` - 可选，如果设置 - 它总是税后价格，
- `original_price_tax` - 可选，如果设置为税额。

笔记

价格`configurable_children`以完全相同的格式为所有人设定

笔记

如果其中任何`configurable_children`一个价格低于主产品，主产品价格将相应更新。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_6-limiting-ssr-html-size-a-k-a-initial-state-optimization)6. 限制 SSR HTML 大小，即 INITIAL_STATE 优化

[服务器端渲染](https://vuejs.org/v2/guide/ssr.html)的主要副作用之一[ （打开新窗口）](https://vuejs.org/v2/guide/ssr.html)是需要在页面水合之前向浏览器提供初始 Vuex 状态。

Hydration 意味着 - Vue.js 使用虚拟生成的 (CSR) Vue.js 组件树填充静态生成的 HTML 标记。**只有经过这个过程，网站才成为互动的**。即使标记略有不同，也可能导致 SSR 水合错误。因此，Vue.js 要求我们[输出`window.__INITIAL_STATE__` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/8f3ce717a823ef3a5c7469082b8a8bcb36abb5c1/core/client-entry.ts#L29)然后用于**替换**Vuex 初始状态。然后，[应用程序变得水润 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/core/client-entry.ts#L111)通过`app.mount()`电话。

唯一的问题是，这`__INITIAL_STATE__`真的很 huuuuuuuge。在类别页面上，包括许多产品列表，它可以以兆字节为单位！Vue Storefront 为您提供了一些控制初始状态的机制。

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#protip-6)专家提示

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-filter-initial-state)1.过滤 `__INITIAL_STATE__`

1. Vue Storefront 为您提供了一种机制来控制`__INITIAL_STATE__` [基于`config.ssr.initialStateFilter` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/8f3ce717a823ef3a5c7469082b8a8bcb36abb5c1/core/scripts/utils/ssr-renderer.js#L40)字段列表。因此，您可以从中删除字段`__INITIAL_STATE__`- 即使使用`.`符号。因此，您可以`attribute`加入列表以删除`attribute`Vuex 模块的整个状态，或者您可以指定`attribute.list_by_code`仅删除该状态。通过使用这种机制，您可以在 SSR 中处理比发送到浏览器更多的数据（参见第 2 点，它与限制处理信息集的方法正好相反）。
2. 您可能还想使用 [`config.entities.*.includeFields` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/8f3ce717a823ef3a5c7469082b8a8bcb36abb5c1/config/default.json#L170)筛选。这些字段列表设置为限制[从 Elasticsearch 加载](https://github.com/vuestorefront/vue-storefront/blob/8f3ce717a823ef3a5c7469082b8a8bcb36abb5c1/core/lib/search.ts#L31)的字段数[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/8f3ce717a823ef3a5c7469082b8a8bcb36abb5c1/core/lib/search.ts#L31). 但是，如果您向实体添加任何新字段，请确保您也将其包含在`includeFields`列表中。

警告

有了这些机制，您必须充分意识到它们可能造成的**水合作用损害**。为了防止任何水合作用问题，您可以使用[`lazy-hydrate` （打开新窗口）](https://github.com/maoberlehner/vue-lazy-hydration)这将让您控制页面上特定部件（组件）的水化流。尤其是[手动补水 （打开新窗口）](https://github.com/maoberlehner/vue-lazy-hydration#manually-trigger-hydration)可能有用。

一般的经验法则是，**当您从初始状态中删除任何内容时，**您应该：

- 尽快在客户端（例如 in `beforeMount`）加载此数据。
- **仅在**加载数据**后才**对组件进行水合。

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-best-practice-for-hydration-from-core-team)2. 核心团队补水最佳实践

看看我们是如何做到的 [`Category.vue` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/ab27bfbd8abef5f1d37666a38fa0387f50ba6eca/src/themes/default/pages/Category.vue#L70)- 水合作用是由手动触发的 [`loading` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/ab27bfbd8abef5f1d37666a38fa0387f50ba6eca/src/themes/default/pages/Category.vue#L70)旗帜。

提示

请确保您是否正在动态加载类别树 - 因为包含所有这些子类别的类别树可能真的很重。默认情况下，Vue Storefront[从 v1.7](https://docs.vuestorefront.io/v1/guide/basics/configuration.html#dynamic-categories-prefetching)提供这种[动态类别预取](https://docs.vuestorefront.io/v1/guide/basics/configuration.html#dynamic-categories-prefetching)。

您最多可以节省 30-40% 的页面大小，从而积极提高 Lighthouse/Pagespeed 分数。然而并不总是能改善用户体验——因为懒惰通常需要您通过另一个网络调用获取所需的数据（可以通过初始状态机制跳过）。

当然，最后请确保您压缩 (gzip + minify) SSR 输出 - 可能在[nginx 级别 （打开新窗口）](https://www.digitalocean.com/community/tutorials/how-to-increase-pagespeed-score-by-changing-your-nginx-configuration-on-ubuntu-16-04)或使用[压缩 （打开新窗口）](https://www.npmjs.com/package/compression)和/或[缩小 （打开新窗口）](https://www.npmjs.com/package/express-minify)中间件添加到 [`core/scripts/server.js`（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/8f3ce717a823ef3a5c7469082b8a8bcb36abb5c1/core/scripts/server.js#L116)



## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_7-url-dispatcher-explained)7. Url Dispatcher 解释

从 Vue Storefront 1.9 开始，我们支持[自定义 url 结构 （打开新窗口）](https://docs.vuestorefront.io/guide/basics/url.html). `UrlDispatcher`在默认情况下启用[`config.seo.useUrlDispatcher` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/3e4191e5e4b1bfc5b349f5d7cff919c695168125/config/default.json#L29).

调度器的业务逻辑已经实现为[Vue路由器守卫 （打开新窗口）](https://router.vuejs.org/guide/advanced/navigation-guards.html)—— [`beforeEach` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/3e4191e5e4b1bfc5b349f5d7cff919c695168125/core/modules/url/router/beforeEach.ts#L41).

调度员首先运行 [`url/mapUrl` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/3e4191e5e4b1bfc5b349f5d7cff919c695168125/core/modules/url/store/actions.ts#L42). 此操作首先检查`state.dispatcherMap`之前注册的 URL 映射。如果未设置映射，则调度程序检查[`localStorage`缓存 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/3e4191e5e4b1bfc5b349f5d7cff919c695168125/core/modules/url/store/actions.ts#L51)只有在此之后`mappingFallback`才会调用该操作。

这是真正映射发生的地方。默认情况下，Vue Storefront 首先根据 Elasticsearch`product`实体检查 URL - 使用`url_path`作为过滤器。如果未找到（统计上，由于产品数量的原因，产品通过 URL 浏览的频率是类别的 10 倍），则发出`category`收集请求。

一旦路线被映射，它就会被[注册 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/3e4191e5e4b1bfc5b349f5d7cff919c695168125/core/modules/url/store/actions.ts#L56)在`dispatcherMap`以不执行在未来更多的网络请求。

优化技巧是 [`category-next/loadCategoryProducts` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/3e4191e5e4b1bfc5b349f5d7cff919c695168125/core/modules/catalog-next/store/category/actions.ts#L100)已经注册了映射 - 因此从类别列表中单击产品不需要任何网络调用来获取正确的路线数据。

正如您可能已经看到的那样，`url/mapUrl`返回数据的格式与 vue-router 使用的路由集合非常相似。**不过，这不是真正的路线**。在由路由器本身处理之前，它`Route`由`processDynamicRoute`助手转换为对象。为了避免我们正在使用的任何用户重定向`RouterManager`到[该路由添加到`vue-router`路由表 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/3e4191e5e4b1bfc5b349f5d7cff919c695168125/core/modules/url/router/beforeEach.ts#L43)并将用户转发到这个新的、完全匹配的路由以呈现正确的页面。

这种机制非常灵活，因为您可以即时添加动态路由。甚至还有一个[社区模块 （打开新窗口）](https://github.com/kodbruket/vsf-mapping-fallback)让您以编程方式映射 url 路由。

笔记

这 [`processDynamicRoute` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/3e4191e5e4b1bfc5b349f5d7cff919c695168125/core/modules/url/helpers/index.ts#L26)确实将`routeData`from转换`url/mapUrl`为**真正的**vue`Route`对象。它的工作原理就像搜索所有由`theme`和注册的路由`modules`。例子：

如果您的路线数据是 ( `routeData`)：

```js
{
  name: 'configurable-product',
  params: {
    slug: product.slug,
    parentSku: product.sku,
    childSku: params['childSku'] ? params['childSku'] : product.sku
}
```

并且您`theme/router/index.js`的定义包含以下定义：( `userRoute`)

```js
  { name: 'configurable-product', path: '/p/:parentSku/:slug/:childSku', component: Product }
```

然后`processDynamicRoute`助手将返回`Route`通过合并`userRoute`与创建的对象`routeData`

```js
  Object.assign({}, userRoute, routeData, { path: '/' + fullRootPath, name: `urldispatcher-${fullRootPath}` })
```

`fullRootPath`是调度程序处理的 url。这个新的虚拟路由被添加到 vue-router 路由表中，用户被转发到它。因此，您可能会看到该`url`模块可以轻松打开/关闭，因为它使用现有 vue-router 上的顶部机制 - 将虚拟 url 映射到现有主题或模块路由。

笔记

为了让它启动并运行，请确保您的`products`和`categories`确实有`url_path`正确的设置和独特的。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_8-multistore-configuration-explained)8. Multistore 配置说明

您可以[在官方文档中](https://docs.vuestorefront.io/v1/guide/integrations/multistore.html#changing-the-ui-for-specific-store-views)了解[基本的 Multistore 配置](https://docs.vuestorefront.io/v1/guide/integrations/multistore.html#changing-the-ui-for-specific-store-views)。Vue Storefront 支持基于`StoreView`级别的多店。

`StoreView` 是一个配置上下文对象，由 Vue Storefront 为每个请求设置 - 可通过 [`currentStoreView()` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/core/lib/multistore.ts#L33)帮手来自 [`multistore.ts` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/core/lib/multistore.ts).

一种`StoreView`通常意味着语言 + 货币的组合。

例子

如果您在每个国家/地区都有一家支持两种语言的商店（例如瑞士支持欧元货币以及法语 + 德语），您最终可能会得到一对两个`StoreViews`：(EUR; DE) + (EUR; FR)。每个`StoreView`都有自己的唯一名称，用于区分和切换站点。

Vue Storefront`StoreViews`允许您区分每个特定站点的所有基本设置。[查看配置 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/af640f3aa0372308db534786fea587b24e8e87d3/config/default.json#L91)：

```json
 "storeViews": {
      "multistore": false,
      "commonCache": true,
      "mapStoreUrlsFor": ["de", "it"],
      "de": {
        "storeCode": "de",
        "disabled": true,
        "storeId": 3,
        "name": "German Store",
        "url": "/de",
        "appendStoreCode": true,
        "elasticsearch": {
          "host": "/api/catalog",
          "index": "vue_storefront_catalog_de"
        },
        "tax": {
          "sourcePriceIncludesTax": false,
          "defaultCountry": "DE",
          "defaultRegion": "",
          "calculateServerSide": true
        },
        "i18n": {
          "fullCountryName": "Germany",
          "fullLanguageName": "German",
          "defaultLanguage": "DE",
          "defaultCountry": "DE",
          "defaultLocale": "de-DE",
          "currencyCode": "EUR",
          "currencySign": "EUR",
          "dateFormat": "HH:mm D-M-YYYY"
        }
      },
      "it": {
        "storeCode": "it",
        "disabled": true,
        "storeId": 4,
        "name": "Italian Store",
        "url": "/it",
        "appendStoreCode": true,
        "elasticsearch": {
          "host": "/api/catalog",
          "index": "vue_storefront_catalog_it"
        },
        "tax": {
          "sourcePriceIncludesTax": false,
          "defaultCountry": "IT",
          "defaultRegion": "",
          "calculateServerSide": true
        },
        "i18n": {
          "fullCountryName": "Italy",
          "fullLanguageName": "Italian",
          "defaultCountry": "IT",
          "defaultLanguage": "IT",
          "defaultLocale": "it-IT",
          "currencyCode": "EUR",
          "currencySign": "EUR",
          "dateFormat": "HH:mm D-M-YYYY"
        }
      }
    }
```

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#protip-7)专家提示

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-create-the-individual-indexes-per-each-specific-storeview)1. 为每个特定创建单独的索引 `StoreView`

首先 - 每个 storeView 都有一个单独的 Elasticsearch 配置。这意味着您可以翻译和存储`product`,`categories`和`attributes`text 属性 - 每个属性都在单独的 Elasticsearch 索引中。

我们的[默认索引器 （打开新窗口）](https://github.com/vuestorefront/mage2vuestorefront#multistore-setup)和[magento2-vsbridge-indexer （打开新窗口）](https://github.com/vuestorefront/magento2-vsbridge-indexer)两者都支持多存储索引。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-setup-the-storeviews-section-in-the-config-local-json)2.设置`storeViews`部分`config/local.json`

每个*storeView*必须有独特的`code`（`it`和`de`在上面的例子中）组+ elasticsearch部指向相应索引。

笔记

请记住[在](https://github.com/vuestorefront/vue-storefront-api/blob/b4198929ef435e20162a192ea2a02cb25e552d45/config/default.json#L50)[配置文件中](https://github.com/vuestorefront/vue-storefront-api/blob/b4198929ef435e20162a192ea2a02cb25e552d45/config/default.json#L50)填充相同的配置[`vue-storefront-api` （打开新窗口）](https://github.com/vuestorefront/vue-storefront-api/blob/b4198929ef435e20162a192ea2a02cb25e552d45/config/default.json#L50). 请确保该`config.availableStores`集合也包含`storeCodes`您将传递给 API 的所有内容。

笔记

仅当`config.storeViews.multistore`设置为`true`（默认值为：）时才应用多商店业务逻辑`false`。

该`storeCode`参数[将作为查询参数 ( `?storeCode`) （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/core/lib/multistore.ts#L105)到所有`vue-storefront-api`让 API 知道要查询哪个后端 API 端点的请求。默认情况下 - 在 Magento 2 中，[我们将适当的添加`storeCode`到 API 请求调用中 （打开新窗口）](https://github.com/vuestorefront/vue-storefront-api/blob/b4198929ef435e20162a192ea2a02cb25e552d45/src/platform/magento2/util.js#L7). 但是，[如果您愿意，](https://github.com/vuestorefront/vue-storefront-api/blob/b4198929ef435e20162a192ea2a02cb25e552d45/src/platform/magento2/util.js#L20)您甚至可以[区分基本 url 或 Magento 2 API 凭据 （打开新窗口）](https://github.com/vuestorefront/vue-storefront-api/blob/b4198929ef435e20162a192ea2a02cb25e552d45/src/platform/magento2/util.js#L20).

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_3-vue-storefront-storecode-resolver)3.Vue Storefront`storeCode`解析器

Vue Storefront 将`currentStoreView`value设置为处理请求的第一件事。它是在[`app.ts:createStore` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/af640f3aa0372308db534786fea587b24e8e87d3/core/app.ts#L73)功能。在`storeCode`从retrived[服务器上下文 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/af640f3aa0372308db534786fea587b24e8e87d3/core/server-entry.ts#L63)或[从当前路线 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/af640f3aa0372308db534786fea587b24e8e87d3/core/server-entry.ts#L67).

这 [`storeCodeFromRoute` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/core/lib/storeCodeFromRoute.ts)helper 支持两种获取当前店铺代码的方式：

1. 从 url 路径：https://test.storefrontcloud.io/de vs. https://test.storefrontcloud.io/it
2. 从[url域名和路径 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/core/lib/storeCodeFromRoute.ts#L30); 通过这种方式，您可以在多个域上运行 Vue Storefront multistore。

笔记

您也可以传递`storeCode`via 服务器上下文。服务器上下文由[`core/scripts/server.ts` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/core/scripts/utils/ssr-renderer.js#L110)- 它来自`ENV.STORE_CODE`或者如果您使用的是 HTTP 代理（如 nginx） - 来自`x-vs-store-code`. 通过这种方式，您可以通过多种不同的方式来区分商店视图实例，而不仅仅是通过域/url。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_4-routing)4. 路由

Vue Storefront 使用[当前](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/src/themes/default/index.js#L31)[代码前缀](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/src/themes/default/index.js#L31)将所有路由添加到路由表中[`storeView` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/src/themes/default/index.js#L31). 如果你的[主题/路由器/index.js （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/src/themes/default/router/index.js)定义了以下路由，并且 `currentStoreVioew().storeCode === 'de'`

```js
 let routes = [
  { name: 'checkout', path: '/checkout', component: Checkout },
  { name: 'legal', path: '/legal', component: Static, props: {page: 'lorem', title: 'Legal Notice'}, meta: {title: 'Legal Notice', description: 'Legal Notice - example of description usage'} },
  { name: 'privacy', path: '/privacy', component: Static, props: {page: 'lorem', title: 'Privacy'} },
```

那么 [`setupMultistoreRoutes` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/core/lib/multistore.ts#L172)helper 将这些路由添加到`vue-router`：

```js
 let routes = [
  { name: 'checkout', path: '/de/checkout', component: Checkout },
  { name: 'legal', path: '/de/legal', component: Static, props: {page: 'lorem', title: 'Legal Notice'}, meta: {title: 'Legal Notice', description: 'Legal Notice - example of description usage'} },
  { name: 'privacy', path: '/de/privacy', component: Static, props: {page: 'lorem', title: 'Privacy'} },
```

修改路由配置的业务逻辑嵌入在 [`localizedRouteConfig` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/core/lib/multistore.ts#L189)帮手。

笔记

当您使用的`storeCode`解析器，基于`domain + path`模式，那么你应该将`config.storeViews.*.appendStoreCode`到`false`。此选项可防止`localizedRouteConfig`帮助程序将 添加`storeCode`为路径，因此可以根据`currentStoreView().url`替代来区分商店视图- 支持`domain + path`.

笔记

请确保您使用相同的`localizedRoute`帮助程序在您的主题中创建链接。此帮助程序支持字符串 URL：

```html
<router-link :to="localizedRoute(page.link)" class="cl-accent relative">{{
  page.title
}}</router-link>
```

或路由对象：

```html
<router-link
  :to="
    localizedRoute({
      name: product.type_id + '-product',
      params: {
        parentSku: product.parentSku ? product.parentSku : product.sku,
        slug: product.slug,
        childSku: product.sku,
      },
    })
  "
></router-link>
```

笔记

`UrlDispatcher`Vue Storefront 1.9 提供的功能也支持多商店路由。该`url_path`字段传递给[`url/mapUrl` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/9dca392a832ba45e9b1c3589eb84f51fbc2e8d6e/core/modules/url/store/actions.ts#L46)action 采用完整的 url - 包括`storeCode`作为入口参数。您可能想使用[vsf-mapping-fallback （打开新窗口）](https://github.com/kodbruket/vsf-mapping-fallback)对于某些覆盖。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_5-customizing-the-theme-per-store-view)5.自定义每个商店视图的主题

您可以`StoreViews`在一个单一的 Vue Storefront 实例中运行所有这些。这是默认模式。在`StoreViews`然后基于该URL /路径/来电请求头或选定的`env`变量。尽可能简单，此模式不会让您为每个人应用完全不同的主题`StoreView`。这是因为主题文件捆绑在`app.js`提供给客户端的捆绑包中。将所有主题捆绑在一起会生成一个非常大的 JS 包并最终减慢页面速度。

您仍然可以`storeView`使用条件`v-if`逻辑和在单个主题中加载特定组件来自定义一些 UI 元素。

笔记

您还可以通过直接在路由表中添加特定的基于商店视图的 url`pages/Category.vue`来修改`theme/router/index.js`路由架构来覆盖一些根级组件（如）。

如果您真的需要为每个人使用不同的主题`storeView`，那么最好的方法是为每个商店视图部署和执行单独的 Vue Storefront 节点实例（例如`de`，在端口 3000、3001`it`上运行等）；然后确保您的代理服务将请求路由到正确的实例。实例可以有不同的配置，包括不同的`config.theme`参数。

您`nginx`对此方案的配置将是这样的：

```text
ProxyPass / http://localhost:3000/
ProxyPassReverse / http://localhost:3000/

ProxyPass /de http://localhost:3001/de
ProxyPassReverse /de http://localhost:3001/de

ProxyPass /it http://localhost:3002/it
ProxyPassReverse /it http://localhost:3002/it
```





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_9-html-minimization-compression-headers)9. HTML 最小化、压缩、标题

Vue Storefront 生成的 HTML 可以很漂亮……很长 😃 我们在这个单个文件中放入了很多 CSS 和 JS。不仅如此，`window.__INITIAL_STATE__`转储中还包含整个 Vuex 状态，以支持客户端数据水化。

为了最大限度地减少浏览器下载初始 SSR 呈现的 HTML 所需的时间，有一些技巧需要实现。

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#protip-8)专家提示

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-compression)1. 压缩

您可能希望在您选择的第一行 HTTP 服务器中启用`gzip/deflate`或`brotli`压缩：`nginx`,`varnish`或`apache`。好消息是 Vue Storefront 也支持`gzip`使用[Express.js 中间件](https://github.com/expressjs/compression)的压缩[`compression` （打开新窗口）](https://github.com/expressjs/compression). 它[在生产模式](https://github.com/vuestorefront/vue-storefront/blob/develop/src/modules/compress/server.ts)下默认启用[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/src/modules/compress/server.ts).

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-html-minimization)2. HTML 最小化

第二种选择是通过删除白色字符来最小化 HTML、CSS 和 JS。此选项默认开启 - 由[`config.server.useHtmlMinifier` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/5f1e36d611c983de252ce08dea78726b6e10044d/config/default.json#L8)转变。我们使用[html-minifier （打开新窗口）](https://www.npmjs.com/package/html-minifier)npm 包以便在这里完成工作。您可能需要调整[`html-minifier`配置 （打开新窗口）](https://www.npmjs.com/package/html-minifier#options-quick-reference)通过调整`config.server.htmlMinifierOptions`属性。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_3-headers)3. 标题

您可以设置各种不同的 HTTP 标头，以便使用 CDN/代理调整边缘缓存策略。您可以在`asyncData`任何根级组件的 中设置输出标头。

```js
<script>
export default {
  name: 'RawOutputExample',
  asyncData ({ store, route, context }) {
    context.server.response.setHeader('ETag', 'custom-value')
    context.server.response.setHeader('Cache-Control', 'max-age=533280')
    return new Promise((resolve, reject) => {
      resolve()
    })
  },
  components: {
  }
}
</script>
```





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_10-production-catalog-indexing-cache-invalidation)10.生产目录索引+缓存失效

虽然很多 Vue Storefornt 项目都是使用[mage2vuestorefront](https://github.com/vuestorefront/mage2vuestorefront/tree/master/src)开发的[ （打开新窗口）](https://github.com/vuestorefront/mage2vuestorefront/tree/master/src)索引器 - 它绝对不是生产就绪的解决方案。主要是因为性能，它不完全支持按需索引（仅实时索引产品和类别的变化）。

由于这个限制，我们创建了一组[本地索引器 （打开新窗口）](https://medium.com/the-vue-storefront-journal/native-magento-data-indexer-aec3c9ebfb).

索引器可用于：

- [Magento 1（打开新窗口）](https://github.com/divanteLtd/magento1-vsbridge-indexer)
- [Magento 2（打开新窗口）](https://github.com/vuestorefront/magento2-vsbridge-indexer)

本机索引器以与`mage2vuestorefront`. 我们的目的是加快索引过程并使其更可靠。通过原生索引器，我们能够使用 Magento 2 ORM 和事件来优化索引过程。`mage2vuestorefront`如果您遇到有关索引性能的任何问题，请务必使用此模块。这两个项目目前都得到了 Vue Storefront Core 团队的官方支持。

启用 SSR 缓存后（请参阅[提示 2](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-ssr-output-cache)），您需要确保正确配置索引器以准确刷新更改的页面。

我们用[产品](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/modules/catalog/helpers/search.ts#L69)标记输出页面[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/modules/catalog/helpers/search.ts#L69)和[类别 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/modules/catalog/store/category/actions.ts#L121)标签。然后所有索引器，包括：`magento1-vsbridge-indexer`, `mage2vuestorefront`,`magento2-vsbridge-indexer`将根据特定产品或类别 ID 使缓存无效。这意味着，该[`invalidate` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/core/scripts/server.js#L156)方法将清除标记有此特定产品 ID 的缓存页面。

笔记

此 URL 要求您传递[配置中](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/config/default.json#L12)设置的失效令牌[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/e96bc3c0d1ef8239bc2e64c399f1fe924cebed36/config/default.json#L12).

如果您正在使用 Varnish 缓存，则标签可用于使其无效。[阅读更多 （打开新窗口）](https://www.drupal.org/docs/8/api/cache-api/cache-tags-varnish).

笔记

所有官方 Vue Storefront 数据索引器，包括[magento1-vsbridge-indexer （打开新窗口）](https://github.com/divanteLtd/magento1-vsbridge-indexer), [magento2-vsbridge-indexer （打开新窗口）](https://github.com/vuestorefront/magento2-vsbridge-indexer)支持缓存失效。如果在 API 和 Vue Storefront 前端应用程序中都启用了缓存，请确保您正确使用了`config.server.invalidateCacheForwardUrl`config 变量，因为索引器只能将缓存无效请求发送到一个 URL（前端或后端），并且它**应该被转发**到其他。请检查 中的默认转发 URL`default.json`并将`key`参数调整为 的值`server.invalidateCacheKey`。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_11-using-magento-checkout)11. 使用 Magento Checkout

Vue Storefront Checkout 已准备好部署到生产环境中。然而，问题是，为了完成，您需要**将 Vue Storefront 与支付提供商集成**。不幸的是，一些流行的 Vue Storefront 支付模块（[Stripe （打开新窗口）](https://forum.vuestorefront.io/t/stripe-payment-integration/155),[支付宝 （打开新窗口）](https://forum.vuestorefront.io/t/paypal-payment-integration/152)) 不支持**状态通知**更改。这主要是因为支付模块也与**平台无关**。状态通知更改必须由您自己实施，具体取决于平台。

话虽如此 - Checkout 集成的其他可行选项之一是[**Magento Checkout Fallback** （打开新窗口）](https://forum.vuestorefront.io/t/external-checkout/150)模块，由[Vendic](http://vendic.nl/)维护[ （打开新窗口）](http://vendic.nl/).

使用此模块时，请确保您已成功分派`cart/sync`(VSF 1.11)、`cart/serverPull`(VSF 1.10) 操作并且同步过程已完成。否则，可能会出现同步尚未完全执行且用户在 Magento 结账时发现 Magento 和 Vue Storefront 购物车之间存在一些差异的情况。例如 - 添加到 VSF 购物车的产品尚未添加到 Magento 购物车。

为避免这种情况，您应该修改[beforeEach （打开新窗口）](https://github.com/Vendic/vsf-external-checkout/blob/baeefd179038b2bd9b4a1a00c95b82b131b61b65/router/beforeEach.ts#L14)：

```js
export function beforeEach(to: Route, from: Route, next) {
  const cartToken: string = rootStore.state.cart.cartServerToken;
  const userToken: string = rootStore.state.user.token;
  const externalCheckoutConfig = {...config.externalCheckout};
  const cmsUrl: string = externalCheckoutConfig.cmsUrl;
  const stores = externalCheckoutConfig.stores;
  const storeCode = currentStoreView().storeCode
  const multistoreEnabled: boolean = config.storeViews.multistore

  if (multistoreEnabled) {
    await rootStore.dispatch('cart/sync')
    if (storeCode in stores && to.name === storeCode + '-checkout') {
      window.location.replace(stores[storeCode].cmsUrl + '/vue/cart/sync/token/' + userToken + '/cart/' + cartToken)
    } else if (storeCode in stores && to.name === 'checkout' && stores[storeCode].cmsUrl !== undefined) {
      window.location.replace(stores[storeCode].cmsUrl + '/vue/cart/sync/token/' + userToken + '/cart/' + cartToken)
    } else {
      next()
    }
  } else {
    if (to.name === 'checkout') {
      window.location.replace(cmsUrl + '/vue/cart/sync/token/' + userToken + '/cart/' + cartToken)
    } else {
      next()
    }
  }
}
```





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_12-elasticsearch-production-setup)12. Elasticsearch 生产设置

Elasticsearch 是 [`vue-storefront-api` （打开新窗口）](https://github.com/vuestorefront/vue-storefront-api)中间件数据源。包含的 Docker 文件应该在开发模式下使用，它们还没有准备好用于生产。

Elasticsearch 应该在集群模式下运行，至少有 3 个节点并且有足够的内存限制（通常每个节点最小大约 8GB）。否则 Elasticsearch 服务将无法提供所需的高可用性级别。

由于 Elasticsearch 是一项 Java 服务，关键设置是 Java 堆大小限制 - 需要将限制设置为为 Elasticsearch 提供足够内存用于搜索操作所需的上限，以及操作系统其他部分所需的最低限制/服务以保持运行。为了不超过容器内存限制。

默认情况下，Elasticsearch 告诉 JVM 使用最小和最大大小为 1 GB 的堆。迁移到生产环境时，重要的是配置堆大小以确保 Elasticsearch 有足够的可用堆。

[引](https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html)自[ElasticSearch 文档（打开新窗口）](https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html)

这些设置的值取决于服务器上可用的 RAM 量：

- 设置`Xmx`和`Xms`你的物理内存不超过50％。Elasticsearch 需要内存用于 JVM 堆以外的用途，为此留出空间很重要。例如，Elasticsearch 使用堆外缓冲区来实现高效的网络通信，依靠操作系统的文件系统缓存来高效访问文件，并且 JVM 本身也需要一些内存。观察 Elasticsearch 进程使用的内存超过使用`Xmx`设置配置的限制是正常的。设置`Xmx`并且`Xms`不超过 JVM 用于压缩对象指针（压缩 oops）的阈值；确切的阈值有所不同，但接近 32 GB。您可以通过在日志中查找如下一行来验证您是否低于阈值：
- 堆的大小`1.9gb`，压缩普通对象指针`true` 理想地设置`Xmx`并`Xms`以不超过该阈值的多个零基于压缩糟糕; 确切的阈值各不相同，但 26 GB 在大多数系统上是安全的，但在某些系统上可能高达 30 GB。您可以通过使用 JVM 选项`-XX:+UnlockDiagnosticVMOptions -XX:`+PrintCompressedOopsMode启动 Elasticsearch并查找如下所示的行来验证您是否低于此阈值：

```log
heap address: 0x000000011be00000, size: 27648 MB, zero based Compressed Oops
showing that zero-based compressed oops are enabled. If zero-based compressed oops are not enabled then you will see a line like the following instead:

heap address: 0x0000000118400000, size: 28672 MB, Compressed Oops with base: 0x00000001183ff000
```

阅读有关[Elasticsearch 部署最佳实践的更多信息（打开新窗口）](https://medium.com/@abhidrona/elasticsearch-deployment-best-practices-d6c1323b25d7)





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_13-htaccess-server-side-redirects-http-codes-and-headers-middlewares)13. .htaccess、服务器端重定向、HTTP 代码和标头、中间件

我们强烈建议在 Vue Storefront 前使用某种 HTTP 服务器作为代理。让它成为`nginx`（在我们的[生产设置文档中](https://docs.vuestorefront.io/v1/guide/installation/production-setup.html)建议）`Varnish`或什至`Apache`. 这些 HTTP 服务器中的任何一个都允许您在 Vue Storefront 之前添加一些授权或重定向层。

这是推荐的方式。

### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#protip-9)专家提示

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_1-advanced-output-processing)1. 高级输出处理

但是，通过使用[高级输出处理，](https://docs.vuestorefront.io/v1/guide/core-themes/layouts.html#how-it-works)您可以轻松地从您想要的 Vue Storefront 站点生成任何文本数据输出。包括 JSON、XML 等。这是一种生成站点地图和其他基于数据的文档的方法。

#### [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_2-express-js-middleware)2.`Express.js`中间件

另一种选择是创建一个`Express.js`中间件。我们`core/scripts/server.ts`是一个经典的 Node.js 应用程序，所以它应该很容易。为此，您可能需要创建一个[服务器模块 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/src/modules/compress/server.ts).

服务器模块位于`src/modules`并始终具有`server.ts`响应少数服务器入口点之一的入口点：

- `afterProcessStarted`-[在服务器启动后立即](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L13)执行[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L13).
- `afterApplicationInitialized`-[在 Express 应用程序初始化后立即](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L34)执行[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L34). 这是绑定新请求处理程序 ( `app.get(...)`, `app.use(...)`)的一个很好的切入点。阅读有关[Express.js 请求处理程序和路由的更多信息 （打开新窗口）](https://expressjs.com/en/guide/routing.html).
- `beforeOutputRenderedResponse`-[在 SSR 渲染完成后](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L189)执行[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L189)但在将其发送到浏览器之前；它允许您用自己的内容覆盖呈现的 SSR 内容。
- `afterOutputRenderedResponse`-[在高级输出处理管道之后](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L212)执行[ （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L212)执行。
- `beforeCacheInvalidated`, `afterCacheInvalidated`-[在缓存失效之前和之后](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L76)执行[（打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/2c6e0e1c8e73952beabf550fe4530344a6bcce15/core/scripts/server.ts#L76)

这是一个[如何绑定](https://github.com/vuestorefront/vue-storefront/blob/develop/src/modules/google-cloud-trace/server.ts)的[示例 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/src/modules/google-cloud-trace/server.ts)服务器进程启动后的跟踪模块：

```js
import { serverHooks } from '@vue-storefront/core/server/hooks'

serverHooks.afterProcessStarted((config) => {
  let trace = require('@google-cloud/trace-agent')
  if (config.has('trace') && config.get('trace.enabled')) {
    trace.start(config.get('trace.config'))
  }
})
```

[另一个例子 （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/develop/src/modules/compress/server.ts)- 非常常见的情况 - 在 SSR 渲染管道（包括自定义 URL 地址）处理所有用户请求之前，绑定新的 Express 中间件来处理所有用户请求：

```js
import { serverHooks } from '@vue-storefront/core/server/hooks'

const compression = require('compression')
serverHooks.afterApplicationInitialized(({ app, isProd }) => {
  if (isProd) {
    console.log('Output Compression is enabled')
    app.use(compression({ enabled: isProd }))
  }
})
```

如果你想绑定自定义 URL 地址，这个例子可以这样修改：

```js
import { serverHooks } from '@vue-storefront/core/server/hooks'

serverHooks.afterApplicationInitialized(({ app, isProd }) => {
  app.get('/custom-url-address', (req, res) => {
    res.end('Custom response')
  })
})
```





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_14-which-fields-of-product-category-and-attribute-are-really-used-by-vsf)14. VSF 真正使用的产品、类别和属性的哪些字段

Vue Storefront 用于产品和类别的数据格式非常复杂，包含一系列可选字段。为了更好地了解哪些字段是真正需要的以及它们是如何工作的 - 请查看[storefront-api （打开新窗口）](https://github.com/vuestorefront/storefront-api/)文档：

- [GraphQL 架构 （打开新窗口）](https://divanteltd.github.io/storefront-graphql-api-schema/)它描述了具有后续类型的产品和类别实体。
- [产品实体 （打开新窗口）](https://sfa-docs.now.sh/guide/integration/format-product.html#product-entity)- 最小的产品字段集以及 VSF 如何使用它们。
- [类别实体 （打开新窗口）](https://sfa-docs.now.sh/guide/integration/format-category.html)- 最小的类别字段集以及 VSF 如何使用它们。
- [属性实体 （打开新窗口）](https://sfa-docs.now.sh/guide/integration/format-attribute.html)- 最小的属性字段集以及 VSF 如何使用它们。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_15-quite-handy-features-in-config-file-properties)15. 配置文件属性中非常方便的功能

Vue Storefront 包含一些非常有用的配置变量，这些变量有时会被遗漏，但可能非常有用（值得一提两次！）：

- `dynamicConfigReload` - 默认情况下，配置文件由 [`node-config` （打开新窗口）](https://github.com/lorenwest/node-config)仅在构建过程中；每当您修改配置文件时，都必须重新编译并捆绑到`app.js`. 但是，在此模式下，[`core/scripts/server.ts` （打开新窗口）](https://github.com/vuestorefront/vue-storefront/blob/77efcdc40a1a69191f8d96c381535517e801820d/core/scripts/server.ts#L271)每次请求都重新加载配置文件。这对于可伸缩性目的和在构建过程中传递一些动态信息可能非常有用。通过修改`dynamicConfigExclude`和`dynamicConfigInclude`数组，您可以更改配置文件的哪些特定部分提供给用户浏览器，哪些不提供。配置通过`window.__INITIAL_STATE__`.
- `useExactUrlsNoProxy`- 设置为 时`true`，在产品属性中设置的字符串：`thumbnail`, `image`... 用于`<img`没有`/api/img`中间件的标签- 作为原始字符串。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_16-cloudflare-autopurge)16. Cloudflare 自动清除

您不仅可以使用 CDN 来提供 dist 和资产目录，还可以使用 SSR 输出。在这种情况下，当 Cloudflare 中的缓存在 Varnish 中被清除时，您可能希望动态地清除它。有一个专门用于此的第 3 方模块！在[此处](https://github.com/new-fantastic/vsf-cloudflare)安装模块[（打开新窗口）](https://github.com/new-fantastic/vsf-cloudflare)





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_17-vsf-cache-varnish)17. VSF 缓存清漆

默认情况下，VSF 能够在 Redis 缓存中缓存 SSR 输出。该模块将在 Varnish 中缓存 Redis 输出。因此，甚至不使用 Node.js 服务器来加载 Redis 的输出。它使我们的应用程序的首次加载速度更快！按照[此处](https://github.com/new-fantastic/vsf-cache-varnish)的说明进行操作[（打开新窗口）](https://github.com/new-fantastic/vsf-cache-varnish)





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_18-vsf-cache-nginx)18.VSF缓存NGINX

默认情况下，VSF 能够在 Redis 缓存中缓存 SSR 输出。该模块将在 NGINX 中缓存 Redis 输出。因此，甚至不使用 Node.js 服务器来加载 Redis 的输出。它使我们的应用程序的首次加载速度更快！按照[此处](https://github.com/new-fantastic/vsf-cache-nginx)的说明进行操作[（打开新窗口）](https://github.com/new-fantastic/vsf-cache-nginx)





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_19-vue-storefront-1-config-validator-for-magento-1-and-magento-2)19. 适用于 Magento 1 和 Magento 2 的 Vue Storefront 1 配置验证器

有一个简单的 PHP CLI 工具可以检查您的 Vue Storefront PWA 配置是否与您的 Magento 站点的结构匹配。无论您的 VSF 与 Magento 1 还是 Magento 2 无缝配合，您都可以放心。请按照[此处](https://github.com/yireo/vsf-config-validator)安装[（打开新窗口）](https://github.com/yireo/vsf-config-validator)





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_20-a-sample-theme-to-start-with)20. 一个示例主题开始

这个[示例主题 （打开新窗口）](https://github.com/yireo-training/vsf-yireo-theme)可以帮助您从 Webpack 配置开始，以允许简单的父/子主题。





## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_21-optimized-webpack-configuration-for-vue-storefront-1-development)21、针对Vue Storefront 1开发优化Webpack配置

Vue Storefront 1 的默认 Webpack 配置允许完全测试所有功能。但是，由于各种原因，这会导致编译时间变慢，从而导致开发人员体验不佳。这个[存储库 （打开新窗口）](https://github.com/yireo-training/vsf1-local-webpack)包含一个单独的 Webpack

## [#](https://docs.vuestorefront.io/v1/guide/cookbook/checklist.html#_22-get-rid-of-depracatedactions-in-vsf-1-12)22. 在 VSF 1.12+ 中摆脱 depracatedActions

我们不想进行**重大更改**（仅在特殊情况下）。这就是我们在产品的 vuex 模块中留下*depracatedActions*的原因。如果你在 1.12 开始你的项目，你几乎可以 100% 确定你可以摆脱这个文件，这将导致app.js 包减少**31.75KB**！简而言之，如果您的应用不使用任何*depracatedActions*，您就可以做到这*一点*。

要做到这一点：

1. 消除 `core/modules/catalog/store/product/deprecatedActions.ts`
2. 在 中`core/modules/catalog/store/product/actions.ts`，删除 317-318 行：

```ts
/** Below actions are not used from 1.12 and can be removed to reduce bundle */
  ...require('./deprecatedActions').default
```